"Lite" {
    "System"
}

Main(->) {
    n0 := <node>(0)
    n1 := <node>(1)
    n2 := <node>(2)
    n3 := <node>(3)
    n4 := <node>(4)
    n5 := <node>(5)
    n6 := <node>(6)

    n0.left = n1
    n0.right = n2

    n1.left = n3
    n1.right = n4

    n2.left = n5
    n2.right = n6

    print("Pre Order Traverse")
    preOrderTraverse(n0)
    print("Middle Order Traverse")
    middleOrderTraverse(n0)
    print("Post Order Traverse")
    postOrderTraverse(n0)

    n7 := inverseNode(n0)
    print("Inverse node")
    preOrderTraverse(n7)

    arr := {9,1,5,8,3,7,4,6,2}
    simpleSort(arr)
    arr = {9,1,5,8,3,7,4,6,2}
    bubbleSort(arr)
    arr = {9,1,5,8,3,7,4,6,2}
    quickSort(arr)

    print("filter Array")
    arr = filterList(arr, {it->it > 4})
    arr @ ea {
        print(ea) 
    }

    print("oop")
    app := <app>("test", "Windows")
    app.start()
    app.stop()
    shutdown(app)
    read()
}

preOrderTraverse(node: ?node->) {
    node ? nil { 
        <- 
    }
    print(node.value)
    preOrderTraverse(node.left)
    preOrderTraverse(node.right)
}

postOrderTraverse(node: ?node->) {
    node ? nil { 
        <-
    }
    postOrderTraverse(node.left)
    postOrderTraverse(node.right)
    print(node.value)
}

middleOrderTraverse(node: ?node->) {
    node ? nil { 
        <-
    }
    middleOrderTraverse(node.left)
    print(node.value)
    middleOrderTraverse(node.right)
}

inverseNode(node: ?node -> node: ?node) {
    node ? nil { 
        <- nil
    }
    node.left = inverseNode(node.left)
    node.right = inverseNode(node.right)

    temp := <node>(node.value)
    temp.left = node.right
    temp.right = node.left
    <- temp
}

swap(list: []int, i: int, j: int->) {
    (list[i], list[j]) = (list[j], list[i])
}

simpleSort(list: []int->) {
    print("simpleSort")
    [0 < list.len] @ i {
        [i+1 < list.len] @ j {
            ? list[i] > list[j] {
                swap(list, i , j)
            }
        }
    }
    list @ ea { 
        print(ea) 
    }
}

bubbleSort(list: []int->) {
    print("bubbleSort")
    [0 < list.len] @ i {
        [list.len-2 >= i] @ j {
            ? list[j] > list[j+1] {
                swap(list, j , j+1)
            }
        }
    }
    list @ ea { 
        print(ea) 
    }
}

quickSort(list: []int->) {
    print("quickSort")
    quickSortImpl(list, 0, list.len-1)
    list @ ea { 
        print(ea) 
    }
}

quickSortImpl(list: []int, low: int, high: int->) {
    pivot := 0
    ? low < high {
        pivot = partition(list, low, high)

        quickSortImpl(list, low, pivot-1)
        quickSortImpl(list, pivot+1, high)
    }
}

partition(list: []int, low: int, high: int -> position: int) {
    pivotKey := list[low]
    
    @ low < high {
        @ low < high & list[high] >= pivotKey {
            high -= 1
        }
        swap(list, low , high)
        @ low < high & list[low] <= pivotKey {
            low += 1
        }
        swap(list, low , high)
    }

    <- low
}

filterList(list: []int, fn: (int -> bool) -> l: []int) {
    filter := []int{}

    list @ ea {
        ? fn(ea) {
            filter += ea
        }
    }
    <- filter
}

shutdown(ctrl: control->) {
    ctrl.shutdown()
}

node -> {
    value: int
    left: ?node
    right: ?node
}
me:node <>(value: int) {
    me.value = value
}

control <- {
    shutdown(->)
}

program -> {
    :control
    name: str
    _running := false
} 
me:program <>(name: str) {
    me.name = name
}

me:program -> {
    start(->) {
        print("Start")
        me._running = true
    }
    stop(->) {
        print("Stop")
        me._running = false
    }
    shutdown(->) {
        print("shutdown")
        me._running = false
    }
}

app -> {
    :program
    platform: str
}
me: app <> (name: str, platform: str)(name) {
    me.platform = platform
}
