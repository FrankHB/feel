demo
{
    .. XyLang\Library,
    System,
    System\IO,
    System\Linq,
    System\ComponentModel\DataAnnotations\Schema,
    System\ComponentModel\DataAnnotations,
    Other.Constant

    Main ()
    {
        Console.WriteLine.("main function")

        TestOperator.()
        TestSwitch.()
        TestIf.()
        TestArray.()
        TestDictionary.()
        TestLoop.()
        (x, _) := TestFunc.("testcall")
        _ = TestFuncParams.(1, 2, (a,b,c: I32, d: I8)->(z: Str, a,b,c: I32)
        {
            <- ("",a,b,c)
        })
        TestCheck.()
        TestTypeConvert.()
        TestEmpty.()
        Console.WriteLine.(TestDefer.().Str)
        TestLambda.()
        _ = <~ TestAsync.()

        p := App.{}

        _ = p.class.c.(1)
        TestInterface.(p.class)

        p.TestFuncTemplate<I32,Str>.(1, "2").TestPackage.()
        
        Console.ReadKey.()
    }

    staticX := 0
    staticY := "hello"
    constZ :== 1024
    staticG :I64
    staticP :Str
    .get { <- (staticY) }
    .set { staticY = value }

    TestOperator ()->()
    {
        i :Str = "128.687"
        i += ".890"
        b :I32
        b = 0
        b += OtherData
        b = + - b
        b -= 1
        b *= 2
        b /= 2
        b %= 5
        i += /" mark String I32 {b} "/
        c := false
        c = ~c
        c = 1 ~= 2
        c = 3 == 3
        c = 3 >= 1
        c = 1 <= 3
        c = true | false
        c = true & false
        Console.WriteLine.(b.ToString.().ToString.())
    }

    TestNullable ()->()
    {
        a: I32? = null
        b: Str? = null
        c: Any? = null
        d: App? = null
    }

    TestTypeConvert ()->()
    {
        x := App.{}
        y := x.!:Program
        z1 := (12.34).ToF32.()
        z2 := z1.ToI64.()
        Console.WriteLine.( z2 )
        Console.WriteLine.( y.?:Program )
        Console.WriteLine.( x.!:Program.Running )
        Console.WriteLine.( ?.(:Program) )
        Console.WriteLine.( ?.(x) )
    }

    TestEmpty ()->()
    {
        x := null.(Program)
        y := null.(class)
        z := null.((a:I32)->(b:I32))
    }

    TestSwitch ()->()
    {
        x :Any = 3
        x.? 1
        {
            Console.WriteLine.(1)
        }
        :Str
        {
            Console.WriteLine.("String")
        }
        :I32
        {
            Console.WriteLine.("int")
        }
        null
        {
            Console.WriteLine.("null")
        }
        _
        {
            Console.WriteLine.("default")
        }
    }

    TestIf ()->()
    {
        x := 5
        ? x == 2
        {
            Console.WriteLine.(2)
        }
        ? x == 3
        {
            Console.WriteLine.(3)
        }
        ?
        {
            Console.WriteLine.("else")
        }
    }

    TestArray ()->()
    {
        arrSingle := [1]
        arrNumber := [1,2,5,6,8,4]
        arrNumber = 0 + arrNumber
        arrNumber += 3 + 7
        arrNumber -= 6
        take := arrNumber.[0]
        take = InPackageArray.{}.Arr.[2]
        arrObj := ["123", 432, App.{}]
        arrArr := [[1,1,1],[1,1,1]]
        arrEmpty := [:I32]
        arrType := [1,2,3:I8]
        arrNumber.@ 
        {
            Console.WriteLine.(it)
        }
        arrNumber.@ item
        {
            Console.WriteLine.(item)
        }
    }

    TestDictionary ()->()
    {
        empty := [Str]I32.{}
        dicSN := ["k1"->1,"k2"->2]
        dicSN += ["k3"->3]
        dicSN -= "k1"
        dicEmpty := [:Str->I32]
        dicType := [1->"v1" :I32->Any]
        Console.WriteLine.(dicSN.["k2"])
    }

    TestCheck ()->()
    {
        y: I32 = (1 + 1).!
        {
            !.(it)
        }
        x: I32 = (1 * 1).! err:IOException 
        {
            !.(err)
        }
    }

    TestDefer ()->(out: Defer)
    {
        x != Defer.{}
        !
        {
            x.Str += "defer 2"
        }
        x.Str = "3"
        !
        {
            x.Str += "defer 4"
        }
        x.Str += "5"
        [0<<3].@
        {
            !
            {
                x.Str += "defer 6"
            }
            x.Str += "7"
        }
        <- (x)
    }

    TestLoop ()->()
    {
        Console.WriteLine.(" 0 to 10")
        [0 << 10].@
        {
            Console.Write.(it)
            Console.Write.(", ")
        }
        Console.WriteLine.("")
        Console.WriteLine.(" 0 to 8 step 2")
        [0 << 8; 2].@
        {
            Console.Write.(it)
            Console.Write.(", ")
        }
        Console.WriteLine.("")
        Console.WriteLine.(" 8 to 2 step 2")
        [8 >> 0; 2].@
        {
            Console.Write.(it)
            Console.Write.(", ")
        }
        Console.WriteLine.("")
        @
        {
            <- @
        }
    }

    TestFunc (Str: Str)->(out1: Str, out2: I32)
    {
        Str = Str + "test"
        i := 1+1*3*9/8
        out2 := i + 5 +(i +8)
        // func in func
        InFunc ()->()
        {
            <- ()
        }
        InFunc.()

        <- (Str, i)
    }

    TestFuncParams (a,b: I32, fn: (a,b,c: I32, d: I8)->(z: Str, a,b,c: I32))->(a: I32, b,c: Str)
    {
        <- (0,"", "")
    }

    TestAsync ()~>(x:I32,y:I32,z:Str)
    {
        <~ Tsk.Delay.(5000)
        Async1 ()~>()
        {
            <~ Tsk.Delay.(5000)
        }
        <~ Async1.()
        
        <- (1, 2, "123")
    }

    TestLambda ()->()
    {
        Test1 (fn: (i1: I32, i2: I32)->(o1: I32, o2: I32))->()
        {
            (o1, o2) := fn.(1, 2)
        }
        Test1.( (i1,i2)<-(i1,i2) )

        Test2 (fn: ()->(o1: I32))->()
        {
            o1 := fn.()
        }
        Test2.( ()<-1 )

        Test3 (fn: (it: I32)->())->()
        {
            fn.(1)
        }
        Test3.( (it:I32)~>()
        {
            <~ Tsk.Delay.(5000)
            Console.WriteLine.(it)
        })
        Test3.( it <~
        {
            <~ Tsk.Delay.(5000)
            Console.WriteLine.(it)
        })
    }

    TestLinq ()->()
    {
        numbers :=  [0, 1, 2, 3, 4, 5, 6]
        arr := `from num in numbers
                where (num % 2) == 0
                orderby num descending
                select num`
    }

    TestInterface (in: class)->() {}

    InPackageArray {} ->
    {
        Arr :[]I32

        ..
        {
            Arr = [1,2,3,4,5,6,7]
        }
    }

    Defer {} ->
    {
        Str :Str
    }

    Defer += IDisposable
    {
        Dispose ()->(){}
    }

    App {}-> Program.{}
    { 
        i := 555
        d := 128.687
        b := "12"
        c := true
        arr := [1,1,1,1]
        _PriName := " program "
        _b := 5
    } 

    App +=
    {
        TestPackage ()->()
        {
            item := Program.{...Name = "new program",Running = true}
            item2 := _
            {
                Name := "new program"
                Running := true
            }
            item3 := []I32.{...1,2,3,4,5}
            item4 := [Str]I32.{..."1"->1,"2"->2,"3"->3}
        }

        TestFuncTemplate<T1,T2> (data1: T1, data2: T2)->(data: App)
        {
            <- (..)
        }
    }

    App += class
    {
        b :I32.get { <- (_b) }

        c (x: I32)->(y: I32)
        {
            <- (x + ..class.b)
        }

        d ()~>(x: I32)
        {
            <~ Tsk.Delay.(5000)
            <- (3)
        }

        e ()~>()
        {
            <~ Tsk.Delay.(5000)
        }

        f :Str
    }

    Result {..data: Str} ->{}

    TestPackageTemplate<T> {}->
    {
        data :T
    }

    TestPackageTemplate<T> +=
    {
        Generic (a:T)->()
        {
        }
    }

    TestProtocolTemplate<T> ->
    {
        Test<T> (in:T)->(){}
    }

    TestImplementTemplate {}->{}
    TestImplementTemplate += TestProtocolTemplate<TestImplementTemplate>
    {
        Test<TestImplementTemplate> (in:TestImplementTemplate)->(){}
    }

    Program {}->
    {
        Name :Str?
        Running :Bool?

        Property :Str?
        .get { <- (Name) }
        .set { Name = value }
    }

    class ->
    {
        b :I32.get{}
        c (x:I32)->(y:I32){}
        d ()~>(y:I32){}
        e ()~>(){}
        f :Str
    }

    \\ Table.{"test"}
    TestAnnotation {}->
    {
        \*Key, Column.{"id"}*\
        Id :Str?
        \\ Column.{"nick_name"}
        NickName :Str?
        \\ Column.{"profile"}
        Profile :Str?
    }

    TestEnum [Ok, Err = -1]
}

Other::Constant
{
    .. XyLang\Library
    OtherData :== 256
}

ImportDemo
{
    .. System, Other, XyLang\Library

    Package {..y: I32}->
    {
        x :I32

        ..
        {
            ..x = Constant.OtherData
        }
    }

    PackageChild {..x, y: I32}-> Package.{y}{}
}