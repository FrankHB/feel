// Grammar Overview

// Name Space
XyLang\Demo
~System
~System\Linq
~System\Collections\Generic
~System\Text
~System\Threading\Tasks
~System\ComponentModel\DataAnnotations\Schema
~System\ComponentModel\DataAnnotations
~..IO.File // 可以隐藏元素使用内容
~List // 需要使用命名空间来使用内容
{
    Demo #
    {
        $
        {
            // Define, Variable，一般情况下编译器会自动判断类型
            string := "10";   // str
            float := 1.2;     // f64
            integer := 123;   // i32
            boolean := true;  // bool
            smallFloat := !.(1.2:f32); // basic type convert

            // Invariable
            const :== 321;

            // Mark String
            format := /"the value is {integer},{float},{boolean}"/;

            // Array
            arr := [1,2,3,4,5]; // []i32
            print.( arr.[0] ); // 使用下标获取
            arrEmpty: []str.{}; // 创建空数组

            // Dictionary, 前面为key，后面为value
            dic := ["1":false, "2":true]; //[str]bool
            print.( dic.["1"] ); // 使用key获取
            dicEmpty: [str]i32.{}; // 创建空字典

            // Function
            fn $(in:i32)->(out:i32){}; // $(i32)->(i32) 

            // Function with no params no return
            doSomeThingVoid $()->()
            {
                doSomeThingA.();
                doSomeThingB.();
            };

            // Full Function with in params and out params
            doSomeThingWithParams $(x:i32, y:str)->(a:i32, b:str)
            {
                <- (x, y);
            };

            b2c.();
            // 使用 _ 舍弃返回值，必须要接收返回值
            _ = a2b.(3, "test");

            // Judge，当表达式的结果只有bool时，相当于if，只当true时才执行
            ? 1+1 ~= 2
            {
                doSomeThingA.();
            }
            ~? // 相当于else
            {
                doSomeThingB.();
            };

            // 当表达式的结果为其它类型时，符合条件的匹配内容被执行
            ? x 
            ~ [0 ~ 6] 
            {
                doSomeThingA.();
            }
            ~ 14 
            {
                doSomeThingB.();
            }
            ~ _ // 缺省执行，省略的话找不到匹配会自动跳出
            {
                doSomeThingC.();
            };

            // Loop, use ~ to take out single item 
            @ array ~ item
            {
                doSomeThingA.();
                doSomeThingB.();
            };

            // 迭代器 [from ~ to; step], step可以省略，默认逐次+1，省略后为 [0 ~ 100]
            @ [0 ~ 100; 2] ~ index
            {
                doSomeThingA.();
                doSomeThingB.();
            };

            // 当没有参数时，无限循环
            @
            {
                doSomeThingA.();
                doSomeThingB.();
                ? a > b 
                {
                    ~@; // jump out loop
                };
            };

            // Package，支持 variable 类型，通常用来包装数据
            View #{}
            {
                Width ^i32;
                Height ^i32;
                Background ^str;
            };

            // 也支持包装方法
            Button #{}
            {
                Width ^i32;
                Height ^i32;
                Background ^str;
                Title ^str;

                Click $()->()
                {
                    // 可以通过 .. 来访问包自身属性或方法
                    print.( ..Title );
                    doSomeThingA.();
                    doSomeThingB.();
                };
            };

            // 可以通过参数标记，让包支持构造方法，默认可以省略
            Image #{w:i32,h:i32,s:str}
            {
                // 私有属性，不能被外部访问，也不能被重包装
                _width := 0;
                _height := 0;
                _source := "";

                // 构造方法
                #
                {
                    // 接收构造参数
                    (_width, _height, _source) = (w,h,s);
                };
            };

            // ReDefine ，对某个包扩展，只允许使用这种方式覆盖同名包，可以用来扩展属性、方法、构造方法
            View #{w:i32, h:i32, s:str}
            {
                #
                {
                    (Width,Height,Source) = (w,h,s);
                };

                Show $()->()
                {
                    doSomeThingA.();
                    doSomeThingB.();
                };

                Hide $()->()
                {
                    doSomeThingA.();
                    doSomeThingB.();
                };
            };

            // Protocol, implemented by package
            Animation & 
            {
                Speed ^i32; // 需求变量，导入的包必须实现定义
                Move $(s:i32)->(); // 需求方法，导入的包必须实现定义
                Event #!PropertyChangedEventHandler;
            };

            // Combine Package，通过引入来复用属性和方法
            ImageButton #{}~View{}
            {
                Title ^str; // 重名自动覆盖，这会代替包原本的属性
                Button ^Button;    // 通过包含其它包，来组合新的包使用

                // Implement protocol
                ~& Animation
                {
                    Speed := 2;

                    Move $(s:i32)->()
                    {
                        t := 5000/s;
                        play.( s + t );
                    };
                };
            };

            // Create an package object
            ib := ImageButton.{};
            // Calling object property
            ib.Title = "OK";
            // Calling object method
            ib.Button.Show.();
            // Calling object protocol
            ib.Animation.Move.(6);

            // Create an object with simple assign
            ib2 := ImageButton.{
                ...Title="Cancel"，Background="red"
            };
            list := []i32.{...1,2,3,4,5};
            map := [str]i32.{..."1":1,"2":2,"3":3};

            // Create an object with params
            img := Image.{30, 20, "./icon.png"};

            // 可以使用 .?type 判断类型，使用 .!type 来转换包类型
            ? ib.?ImageButton 
            {
                ib.!View.Show.();
            };

            // Check, listen the Excption Function
            ! 
            {
                f := readFile.("./test.xy");
            }
            // Catch the report
            ~ err : IOErr
            {
                // Use !~ to declare an Excption
                !~ err;
            };

            file := File.{"./test.xy"};
            // Defer
            ~!
            {
                file.Dispose.();
            };

            // Use ~> to declare Async Function
            task $(in:i32)~>(out:i32)
            {
                // make a function to await
                <~ doSomeThingA.(); 
                doSomeThingB.();
                <~ doSomeThingC.(); 
                <- (in);
            };

            x := task.(6);

            // Annotation 
            \\ assemby: Table{"user"},D{false,Name="d",Hide=true}
            User #{}
            {
                \* Column{"id"}, 
                Required, 
                Key *\
                Id ^str;
                \\ Column{"nick_name"}, Required
                NickName ^str;
                \\ Column{"time_update"}, Required 
                TimeUpdate ^i32;
            };

            // Generic package
            Table<T> #{}
            {
                data ^T;

                setData $(d:T)->()
                {
                    data = d;
                };
            };
            // Generic function
            Add<T> $(x1:T,x2:T)->(y:T)
            {
                <- (x1 + x2);
            };

            // Lambda Function
            arr.select.( $it <- it > 2 );
            arr.each.( $it <- it + 2 );

            // Func params
            Func $(in:(x:i32)->(y:i32))->()
            {
                _ = in.(1);
            };
            Func.( $(x:i32)->(y:i32){
                <- (y);
            });

            // Package
            new #
            {
                Title := "nnn";
                Num := 8;
            };

            // linq
            arr := `from id in expr where expr order expr select expr`;

            // event
            Event #{}
            {
                PropertyChanged #!PropertyChangedEventHandler;
            };

            // control
            Data #{}
            {
                c := 0;
                C ^i32 
                ~get {}
                ~set {};
                
                D ^i32;
                E ^PropertyChangedEventHandler
                ~add {}
                ~remove {};
            };

            // 使用\辅助声明命名空间
            func $(x:\ns\ns2\ns3.pkg)->()
            {
                y := x.!\ns\ns2\ns4.pkg.p;
                z := x.!\ns.pkg.p;
            };

            Color #[Red, Green, Blue];

            // 继承
            Parent #{name:str}
            {
                Name ^str;

                #
                {
                    Name = name;
                };

                GetInfo $()->(info:str)
                {
                    <- (..Name);
                };
            };

            Child #{name,age:str}~Parent{name}
            {
                Age ^str;

                #
                {
                    Age = age;
                };

                ..GetInfo $()->(info:str)
                {
                    <- (..Name + ..Age);
                };
            };
        };
    };
};