// Grammar Overview

// Export Space
:> XyLang.Demo
{
    // Import Space
    <: 
    {
        System;
        .. IO.File; / 可以隐藏元素使用内容
        List; // 需要使用命名空间来使用内容
    };

    $
    {
        // Define, Variable，一般情况下编译器会自动判断类型
        str => "10"; // str
        float => 1.2; // f64
        int => 123; // i32
        bl => true; // bool
        smallFloat => f32(1.2); // basic type convert

        // Invariable
        const == 321;

        // Array
        arr => [1,2,3,4,5]; // []i32
        print.( arr.[0] ); // 使用下标获取
        arrEmpty => #[]str.(); // 创建空数组

        // Dictionary, 前面为key，后面为value
        dic => ["1":false, "2":true]; //[str]bool
        print.( dic.["1"] ); // 使用key获取
        dicEmpty => #[str]i32.(); // 创建空字典

        // Function
        fn => $(in:i32)~(out:i32){}; // $(i32)~(i32) 

        // Function with no params no return
        doSomeThingVoid => $()~()
        {
            doSomeThingA();
            doSomeThingB();
        };

        // Full Function with in params and out params
        doSomeThingWithParams => $(x:i32, y:str)~(a:i32, b:str)
        {
            -> (x, y);
        };

        b2c.();
        // 使用 _ 舍弃返回值，必须要接收返回值
        _ => a2b.(3, "test");

        // Judge，当表达式的结果只有bool时，相当于if，只当true时才执行
        ? 1+1 != 2
        {
            doSomeThingA.();
        }
        ~? // 相当于else
        {
            doSomeThingB.();
        };

        // 当表达式的结果为其它类型时，符合条件的匹配内容被执行
        ? x ~ [0 ~ 6] 
        {
            doSomeThingA.();
        }
        ~ 14 
        {
            doSomeThingB.();
        }
        ~ _ // 缺省执行，省略的话找不到匹配会自动跳出
        {
            doSomeThingC.();
        };

        // Loop, use ~ to take out single item 
        @ array ~ item
        {
            doSomeThingA.();
            doSomeThingB.();
        };

        // 迭代器 [from ~ to; step], step可以省略，默认逐次+1，省略后为 [0 ~ 100]
        @ [0 ~ 100; 2] ~ index
        {
            doSomeThingA.();
            doSomeThingB.();
        };

        // 当没有参数时，无限循环
        @
        {
            doSomeThingA.();
            doSomeThingB.();
            ? a > b 
            {
                ~@; // jump out loop
            };
        };

        // Package，最基础的类型，类型就是自己
        pkg => #(){};

        // Package，只支持 variable 类型，通常用来包装数据
        View => #()
        {
            Width => ^i32;
            Height => ^i32;
            Background => ^str;
        };

        // 也支持包装方法
        Button => #()
        {
            Width => ^i32;
            Height => ^i32;
            Background => ^str;
            Title => ^str;

            Click => $()~()
            {
                // 可以通过 .. 来访问包自身属性或方法
                print.( ..Title );
                doSomeThingA.();
                doSomeThingB.();
            };
        };

        // 可以通过参数标记，让包支持构造方法，默认可以省略
        Image => #(w:i32,h:i32,s:txt)
        {
            // 私有属性，不能被外部访问，也不能被重包装
            _width => 0;
            _height => 0;
            _source => "";

            // 构造方法
            ~#
            {
                // 接收构造参数
                (_width, _height, _source) <= (w,h,s);
            };
        };

        // ReDefine ，对某个包扩展，只允许使用这种方式覆盖同名包，可以用来扩展属性、方法、构造方法
        View => #(w:i32, h:i32, s:txt)
        {
            ~#
            {
                (Width,Height,Source) <= (w,h,s);
            };

            Show => $()~()
            {
                doSomeThingA.();
                doSomeThingB.();
            };

            Hide => $()~()
            {
                doSomeThingA.();
                doSomeThingB.();
            };
        };

        // Protocol, implemented by package
        Animation => & 
        {
            Speed => ^i32; // 需求变量，导入的包必须实现定义
            Move => $(s: i32)~(); // 需求方法，导入的包必须实现定义
            Event => #! PropertyChangedEventHandler;
        };

        // Combine Package，通过引入来复用属性和方法
        ImageButton => #()
        {
            ~# View; // 直接继承，只在c#中有效，不建议使用，将来不实现为c#后会去除
            Title => ^str; // 重名自动覆盖，这会代替包原本的属性
            Button => ^Button;    // 通过包含其它包，来组合新的包使用

            // Implement protocol
            ~& Animation
            {
                Speed => 2;

                Move => $(s: i32)~()
                {
                    t => 5000/s;
                    play.( s + t );
                };
            };
        };

        // Create an package object
        ib => #ImageButton.();
        // Calling object property
        ib.Title <= "OK";
        // Calling object method
        ib.Button.Show.();
        // Calling object protocol
        ib.Animation.Move.(6);

        // Create an object with simple assign
        ib2 => #ImageButton.(){
            Title:"Cancel"
        };

        // Create an object with params
        img => #Image.(30, 20, "./icon.png");

        // 可以使用 .?type 判断类型，使用 .!type 来转换包类型
        ? ib.?ImageButton 
        {
            ib.!View.Show.();
        };

        // Use !~ to declare an Excption
        readFile => $(url: str)~(f: file)
        {
            ? url.length < 1
            {
                // Throw some error
                !~ #IOErr.("URL is none"); 
            };
            -> (System.IO.ReadFile.(url));
        };

        // Check, listen the Excption Function
        ! 
        {
            f => readFile.("./test.xy");
        }
        ~ err 
        {
            // Catch the report
            ? err.?IOErr
            {
                releaseFile.(f);
            };
        };

        ? true
        {
            file => #File.("./test.xy");
            // Defer
            ~!
            {
                file.Dispose.();
            };
            ...
        };

        // Use ~$ to declare Async Function
        task => ~$(in:i32)~(out:i32)
        {
            // make a function to await
            ~$ doSomeThingA.(); 
            doSomeThingB.();
            ~$ doSomeThingC.(); 
            -> (in);
        };

        x => task.(6);

        // 值传递，只有在有明确接收对象（定义、赋值、函数调用）中才有效
        hello => ? isSun
        {
            // 使用 <- 将值传递给左边
            <- ("nice day");
        }
        ~?
        {
            <- ("bad day");
        };

        hellos => @ weatherHistory ~ day
        {
            ? day.isSun
            {
                // 在循环中使用，可以将值插入给外部数组
                <- (day.hello);
            };
        }; 

        // Annotation 
        \*Table.("user")*\
        User => #()
        {
            \*Column.("id"), Required, Key*\
            Id => ^str;
            \*Column.("nick_name"), Required*\ 
            NickName => ^str;
            \*Column.("time_update"), Required*\ 
            TimeUpdate => ^i32;
        };

        // Generic package
        Table<T> => #()
        {
            data => ~:T; // 泛型只能使用~:创建空值

            setData => $ (d: T)
            {
                data <= d;
            };
        };
        // Generic function
        Add<T> => $(x1:T,x2:T)~(y:T)
        {
            -> (x1 + x2);
        };

        // Lambda Function
        arr.select.( $it -> it > 2 );
        arr.each.( $it -> it + 2 );

        // Func params
        Func => $(in: $(x:i32)~(y:i32))~()
        {
            _ <= in.(1);
        };
        Func( $(x:i32)~(y:i32){
            -> (y);
        });

        // Lambda Package
        new => #
        {
            Title: "nnn",
            Num: 8
        };

        // linq
        arr => `from id in expr where expr order expr select expr`;

        // event
        Event => #()
        {
            PropertyChanged => #! PropertyChangedEventHandler;
        };

        // control
        Data => #()
        {
            c => 0;
            C => ^i32 
            ~get {}
            ~set {};
            
            D => ^i32;
            E => ^PropertyChangedEventHandler
            ~add {}
            ~remove {};
        };

        #type; // 直接获取类型
        id.?; // 获取对象类型
    };
};