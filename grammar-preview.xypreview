// Grammar Overview

// Name Space
XyLang\Demo
{
    .. System,
    System\Linq,
    System\Text,
    System\Threading\Tasks,
    System\ComponentModel\DataAnnotations\Schema,
    System\ComponentModel\DataAnnotations,
    IO.File // 可以隐藏元素使用内容

    Main ()
    {
        // Define, Variable，一般情况下编译器会自动判断类型
        string := "10"   // Str
        float := 1.2     // F64
        integer := 123   // I32
        Boolean := true  // Bool
        smallFloat := (1.2).ToF32.() // basic type convert

        // Invariable
        const :== 321

        // Mark String
        format := /"the value is {integer},{float},{Boolean}"/

        // Array
        arr := []I32.{ 1,2,3,4,5 }
        print.( arr.[0] ) // 使用下标获取
        arrEmpty := [:Str] // 创建空数组

        // Dictionary, 前面为key，后面为value
        dic := ["1"->false, "2"->true :[Str]Bool]
        print.( dic.["1"] ) // 使用key获取
        dicEmpty := [:Str->I32] // 创建空字典

        // Function
        fn (in:I32)->(out:I32){} // (I32)->(I32) 

        // Function with no params no return
        doSomeThingVoid ()->()
        {
            doSomeThingA.()
            doSomeThingB.()
        }

        // Full Function with in params and out params
        doSomeThingWithParams (x:I32, y:Str)->(a:I32, b:Str)
        {
            <- (x, y)
        }

        b2c.()
        // 使用 _ 舍弃返回值，必须要接收返回值
        _ = a2b.(3, "test")

        // Judge，当表达式的结果只有Bool时，相当于if，只当true时才执行
        ? 1+1 ~= 2
        {
            doSomeThingA.()
        }
        ? // 相当于else
        {
            doSomeThingB.()
        }

        // pattern match
        x.?
        [0<<6]
        {
            doSomeThingA.()
        }
        14 
        {
            doSomeThingB.()
        }
        _ // 缺省执行，省略的话找不到匹配会自动跳出
        {
            doSomeThingC.()
        }

        // type match
        object.?
        :Str { print.("String") }
        :I32 { print.("integer") }
        :F64 { print.("float") }
        :Bool { print.("Boolean") }
        null { print.("null") }

        // Loop, use identify to take out single item, default is it
        array.@item
        {
            print.(item)
        }

        /* Iterator, Increment [from << to; step], 
        Decrement [from >> to; step], step can omit */
        [0 << 100; 2].@
        {
            print.(it)
        }

        // Infinite
        @
        {
            ? a > b 
            {
                <- @ // jump out loop
            }
        }
        // Conditional
        @ a < 10
        {
            a += 1
        }
        
        // Package，支持 variable 类型，通常用来包装数据
        View {}->
        {
            Width :I32
            Height :I32
            Background :Str
        }

        // 也支持包装方法
        Button {}->
        {
            Width :I32
            Height :I32
            Background :Str
            Title :Str
        }
        Button +=
        {
            Click ()->()
            {
                // 可以通过 .. 来访问包自身属性或方法
                print.( ..Title )
                doSomeThingA.()
                doSomeThingB.()
            }
        }

        // 可以通过参数标记，让包支持构造方法，默认可以省略
        Image {w:I32,h:I32,s:Str}->
        {
            // 私有属性，不能被外部访问，也不能被重包装
            _width := 0
            _height := 0
            _source := ""

            // 构造方法
            ..
            {
                // 接收构造参数
                (_width, _height, _source) = (w,h,s)
            }
        }

        // 自动构造
        View {..Width, ..Height :I32, ..Source:Str}->{}
        // Extension ，对某个包扩展，可以用来扩展方法
        View +=
        {
            Show ()->(){}
            Hide ()->(){}
        }

        // Protocol, implemented by package
        Animation ->
        {
            Speed :I32 // 需求变量，导入的包必须实现定义
            Move (s:I32)->() // 需求方法，导入的包必须实现定义
        }

        // Combine Package，通过引入来复用属性和方法
        ImageButton {}-> View{}
        {
            Title :Str // 重名自动覆盖，这会代替包原本的属性
            Button :Button    // 通过包含其它包，来组合新的包使用 
        }
        // Implement protocol
        ImageButton += Animation
        {
            Speed := 2

            Move (s:I32)->()
            {
                t := 5000/s
                play.( s + t )
            }
        }

        // Create an package object
        ib := ImageButton.{}
        // Calling object property
        ib.Title = "OK"
        // Calling object method
        ib.Button.Show.()
        // Calling object protocol
        ib.Animation.Move.(6)

        // Create an object with simple assign
        ib2 := ImageButton.{
            ...Title="Cancel"，Background="red"
        }
        list := []I32.{...1,2,3,4,5}
        map := [Str]I32.{..."1"->1,"2"->2,"3"->3}

        // Create an object with params
        img := Image.{30, 20, "./icon.png"}

        // 可以使用 .?:type 判断类型，使用 .?=type 来转换包类型
        ? ib.?:ImageButton 
        {
            ib.?=View.Show.()
        }

        //get type
        print.( ?.(ib) )
        print.( ?.(:ImageButton) )

        // Check, listen the Excption Function
        f := readFile.("demo.xy").! {
            !.(it) // Use !.() to declare an Excption
        }

        i : #I32 // convert to origin type

        file := File.{"./test.xy"}
        // Defer
        !
        {
            file.Dispose.()
        }
        // Use
        file2 != File.{"./test.xy"}

        // Use ~> to declare Async Function
        task (in:I32)~>(out:I32)
        {
            // make a function to await
            <~ doSomeThingA.()
            doSomeThingB.()
            <~ doSomeThingC.()
            <- (in)
        }

        x := task.(6)

        // Annotation 
        \\ assemby: Table.{"user"},D.{false,Name="d",Hide=true}
        User {}->
        {
            \* Column.{"id"}, 
            Required, 
            Key *\
            Id :Str
            \\ Column.{"nick_name"}, Required
            NickName :Str
            \\ Column.{"time_update"}, Required 
            TimeUpdate :I32
        }

        // Generic package
        Table<T> {}->
        {
            data :T

            setData (d:T)->()
            {
                data = d
            }
        }
        // Generic function
        Add<T> (x1:T,x2:T)->(y:T)
        {
            <- (x1 + x2)
        }

        // Lambda Function
        arr.select.( it <- it > 2 )
        arr.each.( it <- it + 2 )

        // Func params
        Func (in:(x:I32)->(y:I32))->()
        {
            _ = in.(1)
        }
        Func.( (x:I32)->(y:I32){
            <- (y)
        })

        // Anonymous Package
        new := _
        {
            Title := "nnn"
            Num := 8
        }

        // linq
        arr := `from id in expr where expr order expr select expr`

        // event
        Event {}->
        {
            PropertyChanged #Event PropertyChangedEventHandler
        }

        // control
        Data {}->
        {
            c := 0
            C :I32 
            .get{}
            .set{}
            
            D :I32
            E :PropertyChangedEventHandler
            .add{}
            .remove{}
        }

        // 使用\辅助声明命名空间
        func (x:\ns\ns2\ns3.pkg)->()
        {
            y := \ns\ns2\ns4.pkg.p.{}
            z := \ns.pkg.p.{}
        }

        Color [Red, Green, Blue]
    }
}


