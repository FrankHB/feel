# Grammar Overview

# Name Space
\Xs\Demo {
    Library
    System
    System\Linq
    System\Text
    System\Threading\Tasks
    System\ComponentModel\DataAnnotations\Schema
    System\ComponentModel\DataAnnotations
    IO.File # 可以隐藏元素使用内容
}

program. -> {
    Main() ~> () {
        # Define, Invariable，一般情况下编译器会自动判断类型
        string := "10"   # str
        float := 1.2     # f64
        integer := 123   # i32
        Boolean := true  # bl
        smallFloat := _(1.2).toF32() # basic type convert

        # Variable
        Var := 321

        # Const
        PI 3.141592653

        # Mark String
        format := "the value is {integer},{float},{Boolean}"
        longString := '''
                    can new line  
                    '''

        # List
        arr := [i32]{<- 1,2,3,4,5 }
        arr2 := _{ 1,2,3,4,5}
        cmd.prt( arr[0] ) # 使用下标获取

        # Dictionary, 前面为key，后面为value
        dic := _{"1"->false, "2"->true}
        dic := [str->bl]{<- "1"->false, "2"->true}
        cmd.prt( dic["1"] ) # 使用key获取

        arr: [|i32|] = _{|1,2,3|}
        # Anonymous Package
        new := _{
            Title := "nnn"
            Num := 8
        }

        # Function
        fn(in: i32) -> (out: i32) {} # (i32)->(i32) 

        # Function with no params no return
        doSomeThingVoid() -> () {
            doSomeThingA()
            doSomeThingB()
        }

        # Full Function with in params and out params
        doSomeThingWithParams(x: i32, y: str) -> (a: i32, b: str) {
            <- (x, y)
        }

        b2c()
        # 使用 _ 舍弃返回值，必须要接收返回值
        _ = a2b(3, "test")

        # Judge，当表达式的结果只有Bool时，相当于if，只当true时才执行
        ? 1+1 ~= 2 {
            doSomeThingA()
        } _ { # 相当于else
            doSomeThingB()
        }

        # pattern match
        ? x -> [0<6] {
            doSomeThingA()
        } 14 {
            doSomeThingB()
        } _ { # 缺省执行，省略的话找不到匹配会自动跳出
            doSomeThingC()
        }

        # type match
        ? object -> :str { 
            cmd.prt("string") 
        } :i32 { 
            cmd.prt("integer") 
        } :f64 { 
            cmd.prt("float") 
        } :bl { 
            cmd.prt("boolean") 
        } nil { 
            cmd.prt("nil") 
        }

        # Loop, use identify to take out single item, default is it
        @ item <- array {
            cmd.prt(item)
        }
        # take index and value, both worked at Dictionary
        @ index -> value <- array {
            cmd.prt(index, value)
        }

        # Iterator, Increment [from < to; step], Decrement [from > to; step], step can omit 
        @ [0 < 100; 2] {
            cmd.prt(it)
        }
        @ [10>=1] {}

        # Infinite
        @ {
            ? a > b {
                <- @ # jump out loop
            } _ {
                -> @ # continue
            }
        }
        # Conditional
        A := 0
        @ ? A < 10 {
            A += 1
        }
        
        # Package，支持 variable 类型，通常用来包装数据
        View{} -> {
            Width: i32
            Height: i32
            Background: str
        }

        # 也支持包装方法
        Button{} -> {
            Width: i32
            Height: i32
            Background: str
            Title: str
            
            Click() -> () {
                # 可以通过 .. 来访问包自身属性或方法
                cmd.prt( ..Title )
                doSomeThingA()
                doSomeThingB()
            }
        }

        # 可以通过参数标记，让包支持构造方法，默认可以省略
        Image{w: i32, h: i32, s: str} {
            # 构造方法
            _(_width, _height, _source) = _(w,h,s)
        } -> {
            # 私有属性，不能被外部访问，也不能被重包装
            _width := 0
            _height := 0
            _source := "" 
        }

        # Extension ，对某个包扩展，可以用来扩展方法
        View <- {
            Show() -> () {}
            Hide() -> () {}
            # 重载操作符
            +() -> () {}
            -() -> () {}
        }

        # Protocol, implemented by package
        Animation -> {
            Speed: i32 # 需求变量，导入的包必须实现定义
            Move(s: i32) -> () # 需求方法，导入的包必须实现定义
        }

        # Combine Package，通过引入来复用属性和方法
        ImageButton{} -> View{} {
            Title: str # 重名自动覆盖，这会代替包原本的属性
            Button: Button    # 通过包含其它包，来组合新的包使用 
        } :Animation { # Implement protocol
            Speed := 2

            Move(s: i32) -> () {
                t := 5000/s
                play( s + t )
            }
        }

        # Create an package object
        ib := ImageButton{}
        # Calling object property
        ib.Title = "OK"
        # Calling object method
        ib.Button.Show()
        # Calling object protocol
        ib.Animation.Move(6)

        # Create an object with simple assign
        ib2 := ImageButton{
            <- Title="Cancel"，Background="red"
        }
        list := [i32]{<- 1,2,3,4,5}
        map := [str->i32]{<- "1"->1,"2"->2,"3"->3}

        # Create an object with params
        img := Image{30, 20, "./icon.png"}

        # 可以使用 is<type>() 判断类型，使用 as<type>() 来转换包类型
        ? ib.is<ImageButton>() {
            ib.as<View>().Show()
        }

        # get type
        cmd.prt( ?(ib) )
        cmd.prt( ?(:ImageButton) )

        # Check, listen the Excption Function
        file := File{"./test.xy"}
        ! f := readFile("demo.xy") {
            doSomeThing...
        } -> {
            !(ex) # Use !() to declare an Excption
        } _ {
            file.Dispose()
        }

        # Use ~> to declare Async Function
        task(in: i32) ~> (out: i32) {
            # make a function to await
            <~ doSomeThingA()
            doSomeThingB()
            <~ doSomeThingC()
            <- (in)
        }

        x := task(6)

        # Annotation 
        `assemby: Table{"user"},D{false,Name="d",Hide=true}`
        User{} -> {
            `Column{"id"}, Required, Key`
            Id: str?
            `Column{"nick_name"}, Required`
            NickName: str?
            `Column{"time_update"}, Required`
            TimeUpdate: i32?
        }

        # Generic package
        Table<T>{} -> {
            data: T

            setData(d: T) -> () {
                data = d
            }
        }
        # Generic function
        Add<T>(x1: T, x2: T) -> (y: T) {
            <- (x1 + x2)
        }

        # Lambda Function
        arr.select( ${it -> it > 2} )
        arr.each( $it + 2 )

        # Func params
        Func(in: (x: i32) -> (y: i32)) -> () {
            _ = in(1)
        }
        Func( _(x: i32) -> (y: i32) {
            <- (y)
        })

        # linq
        arr := from id in expr where expr order expr select expr

        # event
        Event{} -> {
            PropertyChanged event PropertyChangedEventHandler
        }

        # control
        Data{} -> {
            c := 0
            C: i32 {
                get{}
                set{}
            }

            D: i32
            E: PropertyChangedEventHandler {
                add{}
                remove{}
            }
        }

        # 使用\辅助声明命名空间
        func(x: \ns\ns2\ns3.pkg) -> () {
            y := \ns\ns2\ns4.pkg.p{}
            z := \ns.pkg.p{}
        }

        Color. -> ?{
            Red 
            Green
            Blue
        }        
    }
}