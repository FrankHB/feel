package

import {
    
}

var a:string = "10"      var a = "10"
const b:int = 6        const b = 6
var c:float = 1.2 is float      var c = 1.2 is float
var d:bool = true      var d = true

var arr = [int]    [1,2,3,4,5]
arr[0]
var map = [string:bool]     ["1":false, "2":true]
map["test"]

if 1 + 1 != 2 {

} else {

}

switch num {
    case 0..6:
    case 14:
    default:
}

for item in array {

}

for i in 0..num step 2 {

}

func a2b (x:int, _ y:string) -> (a:int, b:string) {
    return (a,b)
}
a2b(x:3, "test")


//第一种方案，传统class-interface
class Animal {      //public 
    var type:string
    var age:int

    func init(){
    }
    /*
    var Num:int     //public
    var num:int     //private

    func Cry(){}    //public
    func cry(){}    //private
    */
}

class Dog:Animal ~ run {
    var name:string

    override func init(){
        super.init()
    }

    func cry(){
    }

    interface stop {
        var time:int
        func down(time:int) -> str:string
    }

    func move(age:int, s:stop){
        var t = 60
        s.time = t
        var str = s.down(time: s.time)
        print(str)
    }

    func breath() -> string{
        print("ha")
    }
}

interface run {
    func breath() -> string
    func move(age:int)
}

var d1 = Dog()
d1.name = "Tiny"
d1.cry() 
d1.move(age: 5, ~stop.down(time:int) -> str:string { 
    var t = time
    str = String(t) + "ok"
})

//第二种方案，一切基于interface, class由struct拓展
struct Animal {
    type:string
    age:int
}

struct Dog {
    Animal
}

interface run(x:Dog) {
    
}  