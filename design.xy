package

import {
    
}

//变量、常量
//当存在初始化赋值时，:type 可以省略。例如 var a = "10" 
var a:string = "10"      
const b:int = 6      
var c:float = 1.2 is float
var d:bool = true      

var arr:[int] = [1,2,3,4,5]
arr[0]
var map:[string:bool] = ["1":false, "2":true]
map["test"]
//判断结构
if 1 + 1 != 2 {

} else {

}
//选择结构
switch num {
    case 0..6:
    case 14:
    default:
}
//循环
for item in array {

}
//范围循环
for i in 0..num step 2 {

}
//函数
func a2b (x:int, _ y:string) -> (a:int, b:string) {
    return (a,b)
}
a2b(x:3, "test")


//第一种方案，class-interface，单向继承和接口
class Animal {      //public 
    var type:string
    var age:int

    func init(){
    }
    /*
    var Num:int     //public
    var num:int     //private

    func Cry(){}    //public
    func cry(){}    //private
    */
}

class Dog:Animal ~ Run {
    var name:string

    override func init(){
        super.init()
    }

    func cry(){
    }

    interface stop {
        var time:int
        func down(time:int) -> str:string
    }

    func move(age:int, s:stop){
        s.time = 5000/Run.speed
        var str = s.down(time: s.time)
        print(str)
    }

    func breath() -> string{
        print("ha")
    }
}

interface Run {
    speed:int   //自动静态不可修改
    func breath() -> string     //由class实现
    func move(age:int)
}

var d1 = Dog()
d1.name = "Tiny"
d1.cry() 
d1.move(age: 5, ~stop.down(time:int) -> str:string { 
    var t = time
    str = String(t) + "ok"
})

//第二种方案，struct-interface，无继承组合
struct Animal {
    type:string
    age:int
    init(){}
    cry(){}
}

struct Dog {
    ~Animal
    ~Run

    init(){ //重名自动重载
        super init()
    }
    cry() -> string { //重名自动重载
        //不主动使用super则不会继承原方法
    }
}

interface Run {
    speed:int
    breath() -> string
    move(age:int)
}  