//包
package
//导入
import {
}

//别名
type Int = int

//变量、常量
//当存在初始化赋值时，:type 可以省略。例如 var a = "10" 
//变量
var a:string = "10"      
var c:float = 1.2 is float //强制识别
var d:bool = true    
//常量
const b:int = 6         

//集合
//数组
var arr:[int] = [1,2,3,4,5] //空数组创建 [int]()
arr[0]
//字典
var map:[string:bool] = ["1":false, "2":true]   //空字典创建 [string:bool]()
map["1"]

//判断结构
if 1 + 1 != 2 {
} else {
}

//选择结构
switch num {
    case 0..6:
    case 14:
    default:
}

//遍历循环
for item in array {
}

//范围循环
for i in 0..num step 2 {
}

//条件循环
for a < b {
}

//函数，第二个参数为匿名参数
func a2b (x:int, _ y:string) -> (a:int, b:string) {
    a = x
    b = y
    return //如果不需要做指定的退出，return可以省略。
}
a2b(x:3, "test")

//struct，ext，prot中，变量和方法首字母大写表示public，小写表示private
//结构，变量集合
struct Animal {     //struct只支持变量
    type:string //自动识别为变量
    age:int
    name:string
}
//扩展，结构支持的方法
ext Animal {  //扩展只支持方法,不允许同级重名
    cry(){  //自动识别为方法
    }
    sleep(){
    }
}
struct Pet {
    name:string 
}
ext Pet {  
    sleep(){
    }
}
//组合结构，通过引入功能来继承复数基结构的属性和方法
struct Dog {
    ~Animal //引入基结构
    type:string //重名自动覆盖，这会代替基结构原本的属性
    ~Pet    //当基结构的属性名称唯一时，编译器自动继承。否则不能通过同名直接使用，要么通过子属性访问，要么手动指定名称。
    name~Pet.name //手动重新指定继承
    ~Run //引入协议常量，如果不需要让结构的所有方法都能使用协议的常量，那么可以选择不引入。
}
ext Dog { 
    cry() { //若基结构有重名，自动覆盖
        self.Animal.cry() //手动重载方法，self用来指定自身
    }
    sleep~Pet.sleep //手动重新指定继承
    //实现Run协议
    ~Run { 
        move(s: (int) -> (string) ){
            var t = 5000/SPEED //协议方法可以直接使用协议常量
            var str = s.down(time: t)
            print(str)
        }

        breath() -> string{
            return "ha"
        }
    }
}
//协议，由拓展实现
prot Run {
    SPEED = 5   //自动编译为常量，且必须在接口中初始化
    breath() -> string  //在拓展中实现
    move(s: (int) -> (string))
}

var d1 = Dog()
d1.name = "Tiny"
d1.cry() 
//使用匿名变量舍弃返回值
_ = d1.breath() 
//使用匿名函数
d1.move(s: _ (time:int) -> (str:string) { 
    var t = time
    str = String(t) + "ok"
})