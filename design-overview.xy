//导出
exp A

//导入
imp B

//当存在初始化赋值时，:type 可以省略。例如 var a = "10" 
//变量
var a :string = "10"
var c :number = 1.2 :number //类型识别
var d :bool = true

//不变量
invar e :number = 2

//常量，贯穿生命周期，不会被回收
const B :number = 6

//函数变量
var e :(number) -> (number) //等价于 Function<number><number>{}
var f = _(string) -> (string){ rcv x ; rtn x }("abc") //直接创建匿名函数并执行

//结构变量
var g :{name:string, age:number}
var h = _{name:string, age:number}{name:"Joy", age:5} //直接创建匿名结构并初始化

//数组
var arr :[number] = [1,2,3,4,5] //空数组创建 []:[number] 等价于 List<number>{}
print( arr[0] ) //使用下标获取

//字典，前面为key，后面为value
var dic :[string:bool] = ["1":false, "2":true]   //空字典创建 []:[string:bool] 等价于 Dictionary<string,bool>{}
print( dic["1"] ) //使用key获取

//元组
var tuple1 :(number, number) = (1, 2) //等价于 Tuple<number,number>{}
var tuple2 = (a:1, b:2)

//判断匹配，复合条件的箭头内容被执行，然后自动跳出，无法手动控制
mtch x
{
    0..6 ->
        A
    14 ->
        B 
    _ -> //缺省执行，省略的话找不到匹配会自动跳出
        C 
}

//当参数的结果只有bool时，相当于if，只当true时才执行
mtch 1+1 != 2
{
    A
}

//当没有参数时，只执行条件为true的语句，代替if-elseif-else
mtch
{
    1+1 != 2 -> A
    3-3 > 0 -> B
}

//遍历循环，如果不需要获取值，箭头部分可以省略
lp array -> item
{
    A
    B
}

//范围循环
lp 0..num
{
    A
    B
}

//当没有参数时，无限循环
lp
{
    A
    B
    mtch a > b 
    {
        brk //使用brk跳出循环
        //ctu //使用ctu跳过当前循环
    }
}

//无参数无返回值函数
func b2c() -> ()
{
    A
    B
}

//无名称完整函数，函数第一个括号为元组参数，箭头后的为元组返回值
func c2d(number, string) -> (number, string)
{
    rcv (x, y)  //使用receive来接收参数
    rtn (x, y)  //使用return来返回结果
}

//带名称完整函数，返回值如参数一样，会自动初始化。元组内的名称可以使用 _ 忽略。
func a2b(x:number, _ y:string) -> (a:number, b:string) 
{
    a = x
    b = y
    //如果不需要做指定的退出，rtn可以省略。
}

b2c()
//使用 _ 舍弃返回值，必须要接收返回值
_ = a2b(x:3, "test")

//strc，impl，prot中，变量和方法首字母大写表示public，小写表示private
//结构，属性集合
strc Animal //strc只支持变量
{     
    type :string //自动识别为变量
    age  :number
    name :string
}

//实现，结构支持的方法
impl Animal //实现只支持方法,不允许同级重名
{  
    cry() -> () //自动识别为func
    {  
        A
        B
    }
    sleep() -> ()
    {
        A
        B
    }
}

strc Pet
{
    name :string
}

impl Pet
{  
    sleep() -> ()
    {
        A
        B
    }
}

//组合结构，通过引入功能来继承复数基结构的属性和方法
strc Dog
{
    ~Animal //引入基结构
    type :string //重名自动覆盖，这会代替基结构原本的属性
    ~Pet    //当基结构的属性名称唯一时，编译器自动继承。否则不能通过同名直接使用，要么通过子属性访问，要么手动指定名称。
    name~Pet.name //手动重新指定继承
    ~Run //引入协议常量，如果不需要让结构的所有方法都能使用协议的常量，那么可以选择不引入。
}

impl Dog
{
    cry() -> () //若基结构有重名，自动覆盖
    {
        slf.Animal.cry() //手动重载方法，slf用来指定自身
    }
    sleep~Pet.sleep //手动重新指定继承
    //实现Run协议
    ~Run
    {
        move(s: (number) -> (string) )  -> ()
        {
            invar t = 5000/SPEED //协议方法可以直接使用协议常量
            invar txt = s.down(time: t)
            print(txt)
        }

        breath() -> (string)
        {
            rtn "ha"
        }
    }
}

//协议，由拓展实现
prot Run
{
    SPEED = 5   //自动编译为常量，且必须在协议中初始化
    breath() -> (string) //在拓展中实现
    move(s: (number) -> (string)) -> ()
}

//创建对象
var d1 = Dog{}
//设置对象属性
d1.name = "Tiny"
//调用对象方法
d1.cry()
_ = d1.breath()

//直接在创建对象时赋予属性值
invar d2 = Dog{name:"puppy", age:3}

//使用匿名函数
d1.move(s: _ (time:number) -> (txt:string)
{ 
    invar t = time
    txt = t :string + "ok"
})

//延时任务
df 
{
    A 
}

func readFile(url:string) -> (data:string)
{
    mtch url.length < 1
    {
        rep ErrorInput("URL is none") //报告某个错误
    }
    ...
}

//异常监听
excp
{
    readFile(url:"./test.xy")
}
-> ErrorInput //捕获问题，可以在后面继续添加，或者省略全部
{
    slf.exit(0)
}