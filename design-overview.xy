//导出
xpt A;

//导入
mpt B;

//当存在初始化赋值时，:type 可以省略。例如 vr a = "10" 
//变量
vr a :string = "10";
vr c :number = 1.2 :number; //类型识别
vr d :bool = true;

//不变量
invr e :number = 2;

//函数变量
vr e :(number) -> (number); //等价于 function<number><number>{}
vr f = _(string) -> (string){ rcv x; rtn x; }("abc"); //直接创建匿名函数并执行

//包变量
vr g :{name:string; age:number;};
vr h = _{name:string; age:number;}{name:"Joy", age:5}; //直接创建匿名包并初始化

//数组
vr arr :[number] = [1,2,3,4,5];
//空数组创建 []:[number] 等价于 List<number>{}
print( arr[0] ); //使用下标获取

//字典，前面为key，后面为value
vr dic :[string:bool] = ["1":false, "2":true];   
//空字典创建 []:[string:bool] 等价于 Dictionary<string,bool>{}
print( dic["1"] ); //使用key获取

//元组
vr tuple1 :(number, number) = (1, 2); //等价于 Tuple<number,number>{}
vr tuple2 = (a:1, b:2);

//判断，符合条件的箭头内容被执行，然后自动跳出，无法手动控制
jg x
{
    0..6 ->
        A;
    14 ->
        B;
    _ -> //缺省执行，省略的话找不到匹配会自动跳出
        C;
}

//当参数的结果只有bool时，相当于if，只当true时才执行
jg 1+1 != 2
{
    A;
}

//当没有参数时，只执行条件为true的语句，代替if-elseif-else
jg
{
    1+1 != 2 -> A;
    3-3 > 0 -> B;
}

//遍历循环，如果不需要获取值，箭头部分可以省略
lp array -> item
{
    A;
    B;
}

//范围循环
lp 0..num
{
    A;
    B;
}

//当没有参数时，无限循环
lp
{
    A;
    B;
    jg a > b 
    {
        brk; //使用brk跳出循环
        //cnt; //使用cnt跳过当前循环
    }
}

//无参数无返回值函数
fnc b2c() -> ()
{
    A;
    B;
}

//无名称完整函数，函数第一个括号为元组参数，箭头后的为元组返回值
fnc c2d(number, string) -> (number, string)
{
    rcv (x, y);  //使用rcv来接收参数
    rtn (x, y);  //使用rtn来返回结果
}

//带名称完整函数，返回值如参数一样，会自动初始化。
fnc a2b(x:number, y:string) -> (a:number, b:string)
{
    a = x;
    b = y;
    //如果不需要做指定的退出，rtn可以省略。
}

b2c();
//使用 _ 舍弃返回值，必须要接收返回值
_ = a2b(x:3, y:"test");

//pkg，ptcl中，vr、invr、fnc首字母大写表示public，小写表示private
//包头，属性集合，只能定义一次
pkg hd Animal //hd只支持vr
{
    type :string; //自动识别为vr
    age  :number;
    name :string;
}

//包片段，方法集合，可以定义多次，只要方法不存在重名
pkg frg Animal //frg只支持fnc,不允许同级重名
{
    cry() -> () //自动识别为fnc
    {
        A;
        B;
    }
    sleep() -> ()
    {
        A;
        B;
    }
}

pkg hd Pet
{
    name :string;
}

pkg frg Pet
{
    sleep() -> ()
    {
        A;
        B;
    }
}

//组合包，通过引入来复用属性和方法
pkg hd Dog
{
    ~Animal; //引入包
    type :string; //重名自动覆盖，这会代替包原本的属性
    ~Pet;    //当包的属性名称唯一时，编译器自动继承。否则不能通过同名直接使用，要么通过子属性访问，要么手动指定名称。
    name~Pet.name; //手动重新指定继承
    //实现协议变量
    ~Run
    {
        speed :number;
    }
}

pkg frg Dog
{
    cry() -> () //若包有重名，自动覆盖
    {
        slf.Animal.cry(); //手动重载方法，slf用来指定自身
    }
    sleep~Pet.sleep; //手动重新指定继承
    //实现Run协议
    ~Run
    {
        move(s: (number) -> (string) )  -> ()
        {
            invr t = 5000/Run.HIGHSPEED; //调用协议公开常量
            invr txt = s.down(time: t);
            print(txt);
        }

        breath() -> (string)
        {
            rtn "ha";
        }
    }
}

//协议，由包实现
ptcl Run
{
    vr speed :number; //协议支持变量，在包头中实现，不可在协议中初始化
    invr HIGHSPEED = 10;   //协议的不变量，必须在协议中初始化，作为常量给任意地方使用，只读
    fnc breath() -> (string); //协议的方法，在包片段中实现
    fnc move(s: (number) -> (string)) -> ();
}

//创建对象
vr d1 = Dog{};
//设置对象属性
d1.name = "Tiny";
//调用对象方法
d1.cry();
_ = d1.breath();

//直接在创建对象时赋予属性值
invr d2 = Dog{name:"puppy", age:3};

//使用匿名函数
d1.move(s: _ (time:number) -> (txt:string)
{ 
    invr t = time;
    txt = t :string + "ok";
})

//延时任务
dfr
{
    A;
}

fnc readFile(url:string) -> (data:string)
{
    jg url.length < 1
    {
        rpt ErrorInput("URL is none"); //报告某个错误
    }
    ...
}

//异常检查
chk
{
    readFile(url:"./test.xy");
}
-> ErrorInput //捕获问题，可以在后面继续添加，或者省略全部
{
    slf.exit(0);
}