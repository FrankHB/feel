// Grammar Overview

// Export Space
--> Overview;

// Import Space
<-- System;

// Define, Invariable，当可以明确判断类型时，:type 可以省略。例如 df a = "10";
df str = "10" :string;
df num = 1.2 :number;
df bl = true :bool;

// Variable
df &date = 20171111;

// Array
df arr = [1,2,3,4,5] :[number];
print( arr[0] ); // 使用下标获取

// Dictionary, 前面为key，后面为value
df dic = ["1":false, "2":true] :[string:bool];
print( dic["1"] ); // 使用key获取

// Tuple
df tpl1 = (1, 2) :(number, number); 
df tpl2 = (a:1, b:2);

// Function
df fn = (number) -> (number){} :(number)->(number); 

// Function with no params no return
df doSomeThingVoid = () -> ()
{
    doSomeThingA();
    doSomeThingB();
};

// Full Function with no name, the part of before arrow is params, the part of behind arrow is returns.
df doSomeThingNoName = (number, string) -> (number, string)
{
    <- (x, y);  // use <- to receive params
    -> (x, y);  // use -> to return results
};

// Full Function with name, the returns will be auto init as params.
df doSomeThingHaveName = (x:number, y:string) -> (a:number, b:string)
{
    a = x;
    b = y;
    // if you do not need clear exit, you can pass the ->
};

b2c();
// 使用 _ 舍弃返回值，必须要接收返回值
df _ = a2b(x:3, y:"test");

// Judge，符合条件的匹配内容被执行，然后自动跳出，无法手动控制
jg x
{
    // use cs to catch condition
    cs 0...6 
    {
        doSomeThingA();
    };
    cs 14 
    {
        doSomeThingB();
    };
    cs _ // 缺省执行，省略的话找不到匹配会自动跳出
    {
        doSomeThingC();
    };
};

// 当参数的结果只有bool时，相当于if，只当true时才执行
jg 1+1 != 2
{
    doSomeThingA();
};

// 当没有参数时，只执行条件为true的语句，代替if-elseif-else
jg
{
    cs 1+1 != 2 
    {
        doSomeThingA();
    };
    cs 3-3 > 0 
    {
        doSomeThingB();
    };
};

// Loop, use <- to take out single item 
lp array <- item
{
    doSomeThingA();
    doSomeThingB();
};

// 范围循环，如果不需要获取值，箭头部分可以省略
lp 0...num
{
    doSomeThingA();
    doSomeThingB();
};

// 当没有参数时，无限循环
lp
{
    doSomeThingA();
    doSomeThingB();
    jg a > b 
    {
        brk; // use brk to jump out loop
        //fl; // use fl to jump current time
    };
};

// Package，最基础的类型，类型就是自己
df pkg = #{}:#{};

// Package，只支持 variable 类型，通常用来包装数据
df Animal = # 
{
    type = "";
    age = 0;
    name = "";
};

// 也支持包装方法
df Pet = # 
{
    name = "";

    sleep = () -> ()
    {
        // 可以通过slf来访问内部属性或方法
        print(slf.name);
        doSomeThingA();
        doSomeThingB();
    };
};

// RePackage ，对某个包重新打包，只允许使用这种方式覆盖同名包，可以用来扩展方法
df Animal = # <- Animal  
{
    cry = () -> () 
    {
        doSomeThingA();
        doSomeThingB();
    };
    sleep = () -> ()
    {
        doSomeThingA();
        doSomeThingB();
    };
};

// Protocol, implemented by package
df Run = <-> 
{
    &speed = 0; // 可变量，导入的包必须实现定义
    HIGHSPEED = 10;   // 不可变量，必须在协议中初始化，作为公共属性给任意地方使用，只读
    breath = () -> (string) // 不可变方法，必须在协议中初始化，作为公共方法给任意地方使用，只读
    {
        -> "ha";
    };
    &move = (s: (number) -> (string)) -> (){}; // 可变方法，导入的包必须实现定义
};

// Combine Package，通过引入来复用属性和方法
df Dog = # 
{
    <- Animal; // 引入包
    type = ""; // 重名自动覆盖，这会代替包原本的属性
    <- Pet;    // 当包的属性名称唯一时，编译器自动继承。否则不能通过同名直接使用，要么通过子属性访问，要么手动指定名称。
    name <- Pet.name; // 手动重新指定继承
};

df Dog = # <- Dog
{
    cry = () -> () // 若包有重名，自动覆盖
    {
        slf.Animal.cry(); // 手动重载方法，slf用来指定自身
    };
    sleep <- Pet.sleep; // 手动重新指定继承
    // Implement protocol
    <- Run
    {
        speed = 0;

        move = (s: (number) -> (string) )  -> ()
        {
            df t = 5000/Run.HIGHSPEED; // 调用协议公开常量
            df txt = s.down(time: t);
            print(txt);
            Run.breath(); // 调用协议公开方法
        };
    };
};

// Create an object
df d1 = Dog{};
// Calling object property
d1.name = "Tiny";
// Calling object method
d1.cry();
_ = d1.breath();

// Lambda Function
d1.move(s: (time:number) -> (txt:string)
{ 
    df t = time;
    txt = t :string + "ok";
});

// Use ! to declare an Excption Function
df readFile = (url:string) -> !(data:string)
{
    jg url.length < 1
    {
        // Report some error
        !ErrorInput("URL is none"); 
    };
    data = url;
};

// Check, listen the Excption Function
chk
{
    readFile(url:"./test.xy");
}
-> ErrorInput // Catch the report
{
    slf.exit(0);
};

// Use $ to declare Async Function
df task = $(in:number) -> (out:number)
{
    // Use $ to make a function to await
    $ doSomeThingA(); 
    doSomeThingB();
    $ doSomeThingC(); 
    out = in;
};

df x = task(in: 6);
