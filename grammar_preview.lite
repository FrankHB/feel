# Grammar Overview #

# Name Space #
"lite/demo" {
    "System"
    "System/Linq"
    "System/Text"
    "System/Threading/Tasks"
    "System/ComponentModel/DataAnnotations/Schema"
    "System/ComponentModel/DataAnnotations"
    "IO" File. # 可以隐藏元素使用内容 #
}

Main(~>) {
    # Define, 一般情况下编译器会自动判断类型 #
    String = "10"   # str #
    Number = 1.2    # num #
    Integer = 123   # int #
    Boolean = true  # bool #
    SmallFloat = (1.2).to_f32() # basic type convert #

    # Const #
    PI : 3.141592653

    # Mark String #
    Format = "the value is "Integer","Number","Boolean""

    # List #
    List = []int{ 1,2,3,4,5 }
    List2 = { 1,2,3,4,5 }
    print( List[0] ) # 使用下标获取 #

    # Set #
    Set = [int]{ [1],[2],[3],[4],[5] }
    Set2 = { [1],[2],[3],[4],[5] }

    # Dictionary, 前面为key，后面为value #
    Dictionary = {["1"]false, ["2"]true}
    Dictionary = [str]bool{ ["1"]false, ["2"]true}
    print( Dictionary["1"] ) # 使用key获取 #

    Array []int = array_of(1,2,3)
    # Anonymous Package #
    New = {
        title = "nnn",
        number = 8
    }

    # Function #
    Fn(in int -> out int) {} # (int->int)  #

    # Function with no params no return #
    do_something_void(->) {
        do_something_a()
        do_something_b()
    }

    # Full Function with in params and out params #
    do_something_with_params(x int, y str -> a int, b str) {
        <- x, y
    }

    B2C()
    # 使用 _ 舍弃返回值 #
    _ = A2B(3, "test")

    # Judge，当表达式的结果只有Bool时，相当于if，只当True时才执行 #
    ? 1+1 >< 2 {
        do_something_a()
    } _ { # else #
        do_something_b()
    }

    # pattern match #
    x ? [0<6], 7, 8, 9 {
        do_something_a()
    } 14 {
        do_something_b()
    } _ { # default #
        do_somethingC()
    }

    # type match #
    object ? str { 
        print("string") 
    } int { 
        print("integer") 
    } num { 
        print("float") 
    } bool { 
        print("boolean") 
    } any {
        print("object")
    } nil { 
        print("null") 
    }

    # Loop, use identify to take out single item, default is it #
    item @ array {
        print(item)
    }
    # take index and value, both worked at Dictionary #
    [index]value @ array {
        print(index, value)
    }

    # Iterator, Increment [from < to, step], Decrement [from > to, step], step can omit # 
    it @ [0 < 100, 2] {
        print(it)
    }
    it @ [10>=1] {}

    # Infinite #
    @ {
        ? a > b {
            <- @ # jump out loop #
        } _ {
            -> @ # continue #
        }
    }
    # Conditional #
    a = 0
    @ a < 10 {
        a += 1
    }
    
    # Package，支持 variable 类型，通常用来包装数据 #
    View -> {
        width int
        height int
        background str
    }

    # 也支持包装方法 #
    Button -> {
        width int
        height int
        background str
        title str
    }
    me Button -> { # 可以通过 me 来访问包自身属性或方法 #
        click(->) {
            print( me.title )
            doSomeThingA()
            doSomeThingB()
        }
    } 

    Image -> {
        # 私有属性，不能被外部访问，也不能被重包装 #
        _width = 0
        _height = 0
        _source = "" 
    }
    # 初始化方法 #
    meImage -> {
        init(w int, h int, s str -> vImage) {  
            me._width, me._height, me._source = w,h,s
            <- me
        }
    } 

    # Protocol, implemented by package #
    Animation <- {
        speed() int { get set }    # 需求变量，导入的包必须实现定义 #
        move(s int ->)             # 需求方法，导入的包必须实现定义 #
    }

    # Combine Package，通过引入来复用属性和方法 #
    Image_Button -> {
        # 通过包含其它包，来组合新的包使用  #
        _ Image
        _ Button

        title str
        _speed int
    }  

    # Implement protocol #
    me Image_Button -> Animation {
        speed(me._speed) int
        move(s int ->) {
            t = 5000/s
            play( s + t )
        }
    } 
    me Image_Button <>(w int, h int)(w, h , "img") {
        title = "img btn"
    }

    # Create an package object #
    IB = Image_Button{}
    # Calling property #
    IB.title = "OK"
    # Calling method #
    IB.button.show()
    # Calling protocol #
    IB.move(6)

    # Create an object with simple assign #
    IB2 = Image_Button{
        title="Cancel"，background="red"
    }
    List = []int{1,2,3,4,5}
    Map = [str]int{["1"]1,["2"]2,["3"]3}

    # Create an object with params #
    Img = Image{}.init(30, 20, "./icon.png")
    ImgBtn = <Image_Button>(1, 1)

    # judge type #
    ? IB == <Image_Button> {
        # convert type #
        IB.(View).show()
    }

    # get type #
    print( ?(Image_Button) )

    # Check, listen the Excption Function #
    Fi = File("./test.xs")
    ! F = Read_File("demo.xs")
    ! {
        do_some_thing()
    } ex {
        !(ex) # Use !() to declare an Excption #
    } _ {
        Fi.Dispose()
    }

    # Use ~> to declare Async Function #
    Task(in int ~> out int) {
        # make a function to await #
        <~ do_some_thing_A()
        do some thing B()
        <~ do_some_thing_C()
        <- in
    }

    X = Task(6)

    # Annotation  #
    [assemby-> Table("user"), D(false,Name="d",Hide=true)]
    User -> {
        [Column("id"), Required, Key]
        id str
        [Column("nick_name"), Required]
        nick_name str
        [Column("time_update"), Required]
        time_update int
    }

    # Pointer Type #
    A ?int = nil
    # Get Pointer #
    C = A?
    # Safe Call #
    E = A?.to_str()
    # OrElseValue #
    F = A.or_else(128)

    # Reference #
    Swap(x!int, y!int ->) {
        x, y = y, x
    }
    Swap(A!, B!)
    
    # Generic package #
    Table<T> -> {
        data T
    }
    me Table<T> -> {
        setData(d T ->) {
            data = d
        }
    }
    # Generic function #
    Add<T>(x1 T, x2 T -> y T) {
        <- x1 + x2
    }

    # Lambda Function #
    arr.select( {it -> it > 2} )
    arr.select{it -> it > 2}

    # Func params #
    Func(in (int -> int) ->) {
        in(1)
    }
    Func( (x int -> y int) {
        <- (y)
    })

    # linq #
    arr = from id -> in expr -> where expr -> order expr -> select expr

    # event #
    EventHandle -> {
        property_changed [?]PropertyChangedEventHandler
    }

    # control #
    Data -> {
        _c
        b = 0
        d int
    }
    me Data -> {
        c() int {
            get {
                <- me._c
            }
            set(v) {
                me._c = v
            }
        }
        e() PropertyChangedEventHandler {
            add {
            } 
            remove {
            }
        }
    } 

    Color -> i8[
        Red 
        Green
        Blue
    ]
}