"Lite/Example" {
    "System"
    "System/IO"
    "System/Linq"
    "System/ComponentModel/DataAnnotations/Schema"
    "System/ComponentModel/DataAnnotations"

    "Lite/Example" Example_Static.
}

#
    main function 
#
Main(~>) {
    Print("main function")
    # run test #
    TestType()
    TestOperator()
    TestString()
    TestOptional()
    TestSwitch()
    TestIf()
    TestList()
    TestSet()
    TestDictionary()
    TestLoop()
    X := TestFunc("testcall")
    _ = TestFuncParams(1, 2, 
    (a: Int, b: Int, c: Int, d: I8 -> z: Str, a: Int, b: Int, c: Int) {
        <- "", a, b, c
    })
    TestCheck()
    TestTypeConvert()
    TestDefault()
    TestLambda()
    TestLinq()
    _ = <~ TestAsync()

    Y := TestTuple(1).to_Str()

    P := Lite.Example.App{}

    _ = P.c(1)
    TestInterface(P)

    P.testFuncTemplate<Int, Str>(1, "2").testPackage()
    
    @ True {
        <- @
    }
    
    ? 1 == 1 {
        Print("test exception expression")
    }

    Read()
}

_StaticX := 0 
(_StaticX)StaticX: Int

_StaticY := "hello"
()StaticY: Str {
    get { 
        <- _StaticY
    }
    set(v) { 
        _StaticY = v 
    }
}

Readonly: Read_Only<Int> = RO(5)
StaticG: I64

TestTuple(i: Int -> v: Str) {
    <- "tuple"
}

TestType(->) {
    I1: I8 = 1              # sbyte #
    I2: I16 = 1             # short #
    I3: I32 = 1             # int #
    I4: I64 = 1             # long #
    U1: U8 = 1              # byte #
    U2: U16 = 1             # ushort #
    U3: U32 = 1             # uint #
    U4: U64 = 1             # ulong #
    F1: F32 = 1             # float #
    F2: F64 = 1             # double #
    Char1: Chr = 'a'        # char #
    String1: Str = "123"    # string #
    Bool1: Bool = False     # bool #
    Int1: Int = 1           # int #
    Num1: Num = 1.0         # double #
    Byte1: Byte = 1         # byte #
    Any1: Any = 1           # object #
}

TestOperator(->) {
    I: Str = "128.687"
    I += ".890"
    B: Int
    B = 20190520
    B += ConstData
    B = + - B
    B -= 1
    B *= 2
    B /= 2
    B %= 5
    Print("2 pow 2 = ", 2 ** 2) 
    Print("4 extract root for 2 = ", 4 // 2) 
    Print("4 log with base 2 = ", 4 %% 2) 
    Print(" mark string int " B " ")
    C := False
    C = ~C
    C = 1 >< 2
    C = 3 == 3
    C = 3 >= 1
    C = 1 <= 3
    C = True | False
    C = True & False
    D := (2018.0309).to_Int() 
    D = ~~ D && 1 || 2 ^^ 3 <<1 >> 2
    Print(B.to_Str(), D)
}

TestString(->) {
    "love xs" @ ea {
        ? ea == 'e' {
            Print("love xs")
        }
    }
}

TestOptional(->) {
    A: ?Int = 1
    A?.to_Str()
    B: ?Str = ""
    B?.to_Str()
    C: ?Any = Nil
    D: ?App = Nil
    E: ?[]?Int = []?Int{0}
    E?[0]?.to_Str()?.to_Str()
    F := D.or_else(App{})
}

TestReference(->) {
    x: Int = 1
    y: ?Int = 2
    Swap(a: !Int, b: !?Int ->) {
        (b, a) = (a, b.or_else(2))
    }
    Swap(x!, y!)
}

TestTypeConvert(->) {
    X := App{}
    Y := X:(Program)
    Z1 := (12.34).to_F32()
    Z2 := Z1.to_I64()
    Print( Z2.to<Any>().to<I64>() )
    Print( Y == :Program )
    Print( Y >< :Program )
    Print( X:(Program).running )
    Print( ?(:Program) )
    Print( ?(X) )
}

TestDefault(->) {
    X := Def<Program>()
    Y := Def<Protocol>()
    Z := Def<(Int->Int)>()
}

TestSwitch(->) {
    X :Any = 3
    X ? 1, 2, 3 {
        Print("1,2,3")
    } :Str {
        Print("string")
    } :Int {
        Print("int")
    } Nil {
        Print("null")
    } _ {
        Print("default")
    }
}

TestIf(->) {
    X := 5
    ? X == 2 {
        Print(2)
    } X == 3 {
        Print(3)
    } _ {
        Print("else")
    }
    ? X == 5 {
        Print("yes")
    }
}

TestList(->) {
    Single := {1}
    Numbers := {1,2,5,6,8,4}
    Numbers = Numbers + 0
    Numbers += 3 + 7
    Numbers -= 6
    Take := Numbers[0]
    Take = InPackageArray{}.arr[2]
    Object := {"123", 432, App{}}
    NumbersInNumbers := {{1,1,1}, {1,1,1}}
    NumbersInNumbers[0][0] = 3
    Empty := []Int{}
    Array: [:]Int = Array_of(1,2,3)
    Numbers @ [i]v {
        Print(i, ":", v)
    }
    Slice := Numbers[0<=]
    Slice2 := Numbers[<3]
}

TestSet(->) {
    Empty := [Str]{}
    Numbers: [Int] = {[1],[2],[5],[6],[8],[4]}
    Numbers @ item {
        Print(item)
    }
}

TestDictionary(->) {
    Empty := [Str]Int{}
    Temp := {["k1"]1,["k2"]2}
    Temp += {["k3"]3}
    Temp @ [k]v {
        Print(k)
        Print(v)
    }
    Temp -= "k1"
    Print(Temp["k2"])
}

TestLoop(->) {
    Print(" 0 to 10")
    [0 <= 10] @ i {
        Print(i, ", ", "")
    }
    Print(" ")
    Print(" 0 to 8 step 2")
    [0 < 8, 2] @ ea {
        Print(ea, ", ", "")
    }
    Print(" ")
    Print(" 8 to 2 step 2")
    [8 > 0, 2] @ ea {
        Print(ea, ", ", "")
        ? ea == 6 {
            -> @
        }
    }
    Print(" ")
    @ {
        <- @
    }
    A := 0
    B := 8
    @ A < B {
        A += 1
    }
}

TestCheck(->) {
    Z1: ?Defer = Nil
    Defer{} ! Z2
    ! {
        Z1 = Defer{}
        Defer{} ! Z3
        X := 1 * 1
        Y := 1 + 1
    } ex: IOException {
        !(ex)
    } e {
        !(e)
    } _ {
        ? Z1 >< Nil {
            Z1.Dispose()
        }
    }
}

TestFunc(s: Str = "test" -> out1: Str, out2: Int) {
    s = s + "test"
    I1 := 1+1*3*9/8
    I2 := I1 + 5 + (I1 + 8)
    # func in func #
    Infunc(->) {
        <-
    }
    Infunc()

    <- s, I2
}

TestFuncParams(a: Int, b: Int, fn: (Int, Int, Int, I8 ->
    Str, Int, Int, Int) -> a: Int, b: Str, c: Str) {
    <- 0, "", ""
}

TestLambda(->) {
    Test1(fn: (Int, Int -> Int, Int)->) {
        (O1,O2) := fn(1, 2)
    }
    Test1( {i1,i2 -> (i1,i2)} )

    Test2(fn: (->Int) -> ) {
        O1 := fn()
    }
    Test2{->1}

    Test3(fn: (Int ~> ) -> ) {
        fn(1)
    }
    Test3( (it: Int ~> ) {
        <~ Delay(1000)
        Print(it)
    })
    Test3{it ~>
        <~ Delay(1000)
        Print(it)
    }
    Test4(fn: (Int ~> Int) -> ) { 
        fn(18) 
    }
    Test4{it~>it+1}
}

TestAsync(~> x: Int, y: Int, z: Str) {
    Sleep(1000)
    [1<=10] @ i {
        Go{ ~> 
            <~ Delay(1000)
            Print("task", i)
        }
        Go{ -> 
            <-
        }
    }
    FunWait(~>) {
        <~ Delay(1000)
    }
    <~ FunWait()
    
    <- 1, 2, "123"
}

TestLinq(->) {
    Numbers := {0, 1, 2, 3, 4, 5, 6}
    Linq := from i -> in Numbers -> where (i % 2) == 0 ->
    orderby i -> descending -> select i
    Lambda := Numbers.Where{ i -> i%2==0 }.OrderBy{ i -> i }.ToList()
}

TestInterface(in: Protocol->) {}

ConstData :: 256
ConstData2: Str: "512"
ConstData3: Int: ConstData
ConstFunction(->v: Int) { 
    <- ConstData
}

InPackageArray -> {
    arr: []Int = {1,2,3,4,5,6,7}
}

Defer -> {
    :IDisposable
    data := ""
}

me: Defer -> {
    Dispose(->) {}
} 

App -> {
    :Program
    i := 555
    arr := {1,1,1,1}
    _priName := " Program "
    _b := 5
    _priF := "get"
}

me: App -> {
    testPackage(->) {
        Item := Program{name = "new Program",running = True}
        Item2 := {
            name = "new Program",
            running = True
        }
        Item3 := []Int{1,2,3,4,5}
        Item4 := [Str]Int{["1"]1,["2"]2,["3"]3}
        Item5 := <PackageChild>(1,2) # New #
    }

    testFuncTemplate<T1, T2>(data1: T1, data2: T2 -> data: App) {
        <- me
    }
}

me: App -> Protocol {
    ()b: Int { 
        get { 
            <- me._b
        }
        set(v) { 
            me._b = v 
        }
    }

    (me._priF)f: Str

    c(x: Int -> y: Int) {
        <- x + me.b
    }

    d(~> x: Int) {
        <~ Delay(1000)
        <- 3
    }

    e(~>) {
        <~ Delay(1000)
    }
}

Result -> {
    data: Str
}
me: Result <>(data: Str) {
    me.data = data
}

TestPackageTemplate<T:class> -> {
    data: T
}
me: TestPackageTemplate<T> -> {
    generic(a: T -> ) {}
}

TestProtocolTemplate<T:class> <- {
    test<H:class>(in: H -> )
    test(in: T -> )
}

TestImplementTemplate -> {}
me: TestImplementTemplate -> TestProtocolTemplate<TestImplementTemplate> {
    test(in: TestImplementTemplate -> ) {}
    test<H:class>(in: H -> ) {}
}

Program -> {
    _name: Str
    running: Bool
}

me: Program -> {
    (me._name)name: Str
}

Protocol <- {
    ()b: Int { get set }
    c(x: Int -> y: Int)
    d(~>y: Int)
    e(~>)
    ()f: Str
}

[Table("test")]
TestAnnotation -> {
    [Key, Column("id")]
    id: Str
    [Column("nick_name")]
    nickName: Str
    [Column("profile")]
    profile: Str
}

TestEnum -> Int[
    OK
    Error = -1
]

Package -> {
    x: Int
    y: Int
}
me: Package <>(y: Int = 3) {
    me.x = ConstData
    me.y = y
}
me: Package -> {
    parentFunc(->) {
        me.x = 21
        Print("package")
    }
}

PackageChild -> {
    :Package
    x: Int
}
me: PackageChild <>(x: Int, y: Int)(y) {
    me.x = x
}
(super)me: PackageChild  -> {
    parentFunc(->) {
        super.x = 64
        Print("package child")
    }
}
