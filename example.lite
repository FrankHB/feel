"Lite/Example" {
    "System"
    "System/IO"
    "System/Linq"
    "System/ComponentModel/DataAnnotations/Schema"
    "System/ComponentModel/DataAnnotations"

    "Lite/Example" Example_Static.
}

#
    main function 
#
Main(~>) {
    print("main function")
    # run test #
    testType()
    testOperator()
    testString()
    testOptional()
    testSwitch()
    testIf()
    testList()
    testSet()
    testDictionary()
    testLoop()
    x := testFunc("testcall")
    _ = testFuncParams(1, 2, 
    (a: int, b: int, c: int, d: i8 -> z: str, a: int, b: int, c: int) {
        <- "", a, b, c
    })
    testCheck()
    testTypeConvert()
    testDefault()
    testLambda()
    testLinq()
    _ = <~ testAsync()

    y := testTuple(1).to_str()

    p := Lite.Example.app{}

    _ = p.c(1)
    test_interface(p)

    p.test_func_template<int, str>(1, "2").test_package()
    
    @ true {
        <- @
    }
    
    ? 1 == 1 {
        print("test exception expression")
    }

    read()
}

_StaticX := 0 
StaticX(_StaticX): int

_StaticY := "hello"
StaticY(): str {
    get { 
        <- _StaticY
    }
    set(v) { 
        _StaticY = v 
    }
}

StaticG: i64

testTuple(i: int -> v: str) {
    <- "tuple"
}

testType(->) {
    I1: i8 = 1              # sbyte #
    I2: i16 = 1             # short #
    I3: i32 = 1             # int #
    I4: i64 = 1             # long #
    U1: u8 = 1              # byte #
    U2: u16 = 1             # ushort #
    U3: u32 = 1             # uint #
    U4: u64 = 1             # ulong #
    F1: f32 = 1             # float #
    F2: f64 = 1             # double #
    Char1: chr = 'a'        # char #
    String1: str = "123"    # string #
    Bool1: bool = false     # bool #
    Int1: int = 1           # int #
    Num1: num = 1.0         # double #
    Byte1: byte = 1         # byte #
    Any1: any = 1           # object #
}

testOperator(->) {
    I: str = "128.687"
    I += ".890"
    B: int
    B = 20190520
    B += ConstData
    B = + - B
    B -= 1
    B *= 2
    B /= 2
    B %= 5
    print("2 pow 2 = ", 2 ** 2) 
    print("4 extract root for 2 = ", 4 // 2) 
    print("4 log with base 2 = ", 4 %% 2) 
    print(" mark string int " B " ")
    C := false
    C = ~C
    C = 1 >< 2
    C = 3 == 3
    C = 3 >= 1
    C = 1 <= 3
    C = true | false
    C = true & false
    D := (2018.0309).to_int() 
    D = ~~ D && 1 || 2 ^^ 3 <<1 >> 2
    print(B.to_str(), D)
}

testString(->) {
    "love xs" @ ea {
        ? ea == 'e' {
            print("love xs")
        }
    }
}

testOptional(->) {
    A: ?int = 1
    A?.to_str()
    B: ?str = ""
    B?.to_str()
    C: ?any = nil
    D: ?app = nil
    E: ?[]?int = []?int{0}
    E?[0]?.to_str()?.to_str()
    F := D.or_else(app{})
}

TestReference(->) {
    x: int = 1
    y: ?int = 2
    swap(a: !int, b: !?int ->) {
        (b, a) = (a, b.or_else(2))
    }
    swap(x!, y!)
}

testTypeConvert(->) {
    x := app{}
    y := x:(program)
    z1 := (12.34).to_f32()
    z2 := z1.to_i64()
    print( z2.to<any>().to<i64>() )
    print( y == :program )
    print( y >< :program )
    print( x:(program).running )
    print( ?(:program) )
    print( ?(x) )
}

testDefault(->) {
    x := def<program>()
    y := def<Protocol>()
    Z := def<(int->int)>()
}

testSwitch(->) {
    x :any = 3
    x ? 1, 2, 3 {
        print("1,2,3")
    } :str {
        print("string")
    } :int {
        print("int")
    } nil {
        print("null")
    } _ {
        print("default")
    }
}

testIf(->) {
    x := 5
    ? x == 2 {
        print(2)
    } x == 3 {
        print(3)
    } _ {
        print("else")
    }
    ? x == 5 {
        print("yes")
    }
}

testList(->) {
    Single := {1}
    Numbers := {1,2,5,6,8,4}
    Numbers = Numbers + 0
    Numbers += 3 + 7
    Numbers -= 6
    Take := Numbers[0]
    Take = InPackageArray{}.arr[2]
    Object := {"123", 432, app{}}
    NumbersInNumbers := {{1,1,1}, {1,1,1}}
    NumbersInNumbers[0][0] = 3
    Empty := []int{}
    Array: [:]int = Array_of(1,2,3)
    Numbers @ [i]v {
        print(i, ":", v)
    }
    Slice := Numbers[0<=]
    Slice2 := Numbers[<3]
}

testSet(->) {
    Empty := [str]{}
    Numbers: [int] = {[1],[2],[5],[6],[8],[4]}
    Numbers @ item {
        print(item)
    }
}

testDictionary(->) {
    Empty := [str]int{}
    Temp := {["k1"]1,["k2"]2}
    Temp += {["k3"]3}
    Temp @ [k]v {
        print(k)
        print(v)
    }
    Temp -= "k1"
    print(Temp["k2"])
}

testLoop(->) {
    print(" 0 to 10")
    [0 <= 10] @ i {
        print(i, ", ", "")
    }
    print(" ")
    print(" 0 to 8 step 2")
    [0 < 8, 2] @ ea {
        print(ea, ", ", "")
    }
    print(" ")
    print(" 8 to 2 step 2")
    [8 > 0, 2] @ ea {
        print(ea, ", ", "")
        ? ea == 6 {
            -> @
        }
    }
    print(" ")
    @ {
        <- @
    }
    A := 0
    B := 8
    @ A < B {
        A += 1
    }
}

testCheck(->) {
    z1: ?Defer = nil
    Defer{} ! z2
    ! {
        z1 = Defer{}
        Defer{} ! Z3
        x := 1 * 1
        y := 1 + 1
    } ex: IOException {
        !(ex)
    } e {
        !(e)
    } _ {
        ? z1 >< nil {
            z1.Dispose()
        }
    }
}

testFunc(s: str = "test" -> out1: str, out2: int) {
    s = s + "test"
    I1 := 1+1*3*9/8
    I2 := I1 + 5 + (I1 + 8)
    # func in func #
    Infunc(->) {
        <-
    }
    Infunc()

    <- s, I2
}

testFuncParams(a: int, b: int, fn: (int, int, int, i8 ->
    str, int, int, int) -> a: int, b: str, c: str) {
    <- 0, "", ""
}

testLambda(->) {
    Test1(fn: (int, int -> int, int)->) {
        (O1,O2) := fn(1, 2)
    }
    Test1( {i1,i2 -> (i1,i2)} )

    Test2(fn: (->int) -> ) {
        O1 := fn()
    }
    Test2{->1}

    Test3(fn: (int ~> ) -> ) {
        fn(1)
    }
    Test3( (it: int ~> ) {
        <~ delay(1000)
        print(it)
    })
    Test3{it ~>
        <~ delay(1000)
        print(it)
    }
    Test4(fn: (int ~> int) -> ) { 
        fn(18) 
    }
    Test4{it~>it+1}
}

testAsync(~> x: int, y: int, z: str) {
    sleep(1000)
    [1<=10] @ i {
        go{ ~> 
            <~ delay(1000)
            print("task", i)
        }
        go{ -> 
            <-
        }
    }
    FunWait(~>) {
        <~ delay(1000)
    }
    <~ FunWait()
    
    <- 1, 2, "123"
}

testLinq(->) {
    Numbers := {0, 1, 2, 3, 4, 5, 6}
    Linq := from i -> in Numbers -> where (i % 2) == 0 ->
    orderby i -> descending -> select i
    Lambda := Numbers.Where{ i -> i%2==0 }.OrderBy{ i -> i }.ToList()
}

test_interface(in: Protocol->) {}

ConstData :: 256
ConstData2: str: "512"
ConstData3: int: ConstData
ConstFunction(->v: int) { 
    <- ConstData
}

InPackageArray -> {
    arr: []int = {1,2,3,4,5,6,7}
}

Defer -> {
    :IDisposable
    data := ""
}

me: Defer -> {
    Dispose(->) {}
}

app -> {
    :program
    i := 555
    arr := {1,1,1,1}
    _priName := " program "
    _b := 5
    _priF := "get"
}

me: app -> {
    test_package(->) {
        Item := program{name = "new program",running = true}
        Item2 := {
            name = "new program",
            running = true
        }
        Item3 := []int{1,2,3,4,5}
        Item4 := [str]int{["1"]1,["2"]2,["3"]3}
        Item5 := <package_child>(1,2) # New #
    }

    test_func_template<T1, T2>(data1: T1, data2: T2 -> data: app) {
        <- me
    }
}

me: app -> Protocol {
    b(): int { 
        get { 
            <- me._b
        }
        set(v) { 
            me._b = v 
        }
    }

    f(me._priF): str

    c(x: int -> y: int) {
        <- x + me.b
    }

    d(~> x: int) {
        <~ delay(1000)
        <- 3
    }

    e(~>) {
        <~ delay(1000)
    }
}

Result -> {
    data: str
}
me: Result <>(data: str) {
    me.data = data
}

TestPackageTemplate<T:class> -> {
    data: T
}
me: TestPackageTemplate<T> -> {
    generic(a: T -> ) {}
}

TestProtocolTemplate<T:class> <- {
    test<H:class>(in: H -> )
    test(in: T -> )
}

TestImplementTemplate -> {}
me: TestImplementTemplate -> TestProtocolTemplate<TestImplementTemplate> {
    test(in: TestImplementTemplate -> ) {}
    test<H:class>(in: H -> ) {}
}

program -> {
    _name: str
    running: bool
}

me: program -> {
    name(me._name): str
}

Protocol <- {
    b(): int { get set }
    c(x: int -> y: int)
    d(~>y: int)
    e(~>)
    f(): str
}

[Table("test")]
TestAnnotation -> {
    [Key, Column("id")]
    id: str
    [Column("nick_name")]
    nickName: str
    [Column("profile")]
    profile: str
}

TestEnum -> int[
    OK
    Error = -1
]

package -> {
    x: int
    y: int
}
me: package <>(y: int = 3) {
    me.x = ConstData
    me.y = y
}
me: package -> {
    parentFunc(->) {
        me.x = 21
        print("package")
    }
}

package_child -> {
    :package
    x: int
}
me: package_child <>(x: int, y: int)(y) {
    me.x = x
}
(super)me: package_child  -> {
    parentFunc(->) {
        super.x = 64
        print("package child")
    }
}
