"Lite/Example" {
    "System"
    "System/IO"
    "System/Linq"
    "System/ComponentModel/DataAnnotations/Schema"
    "System/ComponentModel/DataAnnotations"

    "Lite/Example" Example_Static.
}

#
    main function 
#
Main() ~> () {
    Prt("main function")
    # run test #
    TestType()
    TestOperator()
    TestString()
    TestOptional()
    TestSwitch()
    TestIf()
    TestList()
    TestSet()
    TestDictionary()
    TestLoop()
    X := TestFunc("testcall")
    _ = TestFuncParams(1, 2, 
    (a: Int, b: Int, c: Int, d: I8) -> (z: Str, a: Int, b: Int, c: Int) {
        <- ("", a, b, c)
    })
    TestCheck()
    TestTypeConvert()
    TestDefault()
    TestLambda()
    TestLinq()
    _ = <~ TestAsync()

    Y := TestTuple(1).to_Str()

    P := App{}

    _ = P.c(1)
    TestInterface(P)

    P.testFuncTemplate<Int, Str>(1, "2").testPackage()
    
    @ True {
        <- @
    }
    
    ? 1 == 1 {
        Prt("test exception expression")
    }

    Rd()
}

_StaticX := 0 
StaticX: Int -> get {
    <- (_StaticX)
}

_StaticY := "hello"
StaticY: Str -> get { 
    <- (_StaticY) 
} set(v) { 
    _StaticY = v 
}

Readonly: Read_Only<Int> = RO(5)
StaticG: I64

TestTuple(i: Int) -> (v: Str) {
    <- ("tuple")
}

TestType() -> () {
    I1: I8 = 1              # sbyte #
    I2: I16 = 1             # short #
    I3: I32 = 1             # int #
    I4: I64 = 1             # long #
    U1: U8 = 1              # byte #
    U2: U16 = 1             # ushort #
    U3: U32 = 1             # uint #
    U4: U64 = 1             # ulong #
    F1: F32 = 1             # float #
    F2: F64 = 1             # double #
    Char1: Chr = 'a'        # char #
    String1: Str = "123"    # string #
    Bool1: Bool = False     # bool #
    Int1: Int = 1           # int #
    Num1: Num = 1.0         # double #
    Byte1: Byte = 1         # byte #
    Any1: Any = 1           # object #
}

TestOperator() -> () {
    I: Str = "128.687"
    I += ".890"
    B: Int
    B = 20190520
    B += ConstData
    B = + - B
    B -= 1
    B *= 2
    B /= 2
    B %= 5
    Prt("2 pow 2 = ", 2 ** 2) 
    Prt("4 extract root for 2 = ", 4 // 2) 
    Prt("4 log with base 2 = ", 4 %% 2) 
    Prt(" mark string int " B " ")
    C := False
    C = ~C
    C = 1 >< 2
    C = 3 == 3
    C = 3 >= 1
    C = 1 <= 3
    C = True | False
    C = True & False
    D := (2018.0309).to_Int() 
    D = D.and(1).or(2).xor(3).not().lft(1).rht(2)
    Prt(B.to_Str())
}

TestString() -> () {
    "love xs" @ ea {
        ? ea == 'e' {
            Prt("love xs")
        }
    }
}

TestOptional() -> () {
    A: ?Int = 1
    A?.to_Str()
    B: ?Str = ""
    B?.to_Str()
    C: ?Any = Nil
    D: ?App = Nil
    E: ?[]?Int = []?Int{0}
    E?[0]?.to_Str()?.to_Str()
    F := D.or_else(App{})
}

TestReference() -> () {
    x: Int = 1
    y: ?Int = 2
    Swap(a: !Int, b: !?Int) -> () {
        (b, a) = (a, b.or_else(2))
    }
    Swap(x!, y!)
}

TestTypeConvert() -> () {
    X := App{}
    Y := X:(Program)
    Z1 := (12.34).to_F32()
    Z2 := Z1.to_I64()
    Prt( Z2.to<Any>().to<I64>() )
    Prt( Y == :Program )
    Prt( Y >< :Program )
    Prt( X:(Program).running )
    Prt( ?(:Program) )
    Prt( ?(X) )
}

TestDefault() -> () {
    X := Def<Program>()
    Y := Def<Protocol>()
    Z := Def<(Int)->(Int)>()
}

TestSwitch() -> () {
    X :Any = 3
    X ? 1 {
        Prt(1)
    } :Str {
        Prt("string")
    } :Int {
        Prt("int")
    } Nil {
        Prt("null")
    } _ {
        Prt("default")
    }
}

TestIf() -> () {
    X := 5
    ? X == 2 {
        Prt(2)
    } X == 3 {
        Prt(3)
    } _ {
        Prt("else")
    }
    ? X == 5 {
        Prt("yes")
    }
}

TestList() -> () {
    Single := {1}
    Numbers := {1,2,5,6,8,4}
    Numbers = Numbers + 0
    Numbers += 3 + 7
    Numbers -= 6
    Take := Numbers[0]
    Take = InPackageArray{}.arr[2]
    Object := {"123", 432, App{}}
    NumbersInNumbers := {{1,1,1}, {1,1,1}}
    Empty := []Int{}
    Array: [:]Int = Array_of(1,2,3)
    Numbers @ [i]v {
        Prt(i, ":", v)
    }
    Slice := Numbers[0<=]
    Slice2 := Numbers[<3]
}

TestSet() -> () {
    Empty := [Str]{}
    Numbers: [Int] = {[1],[2],[5],[6],[8],[4]}
    Numbers @ item {
        Prt(item)
    }
}

TestDictionary() -> () {
    Empty := [Str]Int{}
    Temp := {["k1"]1,["k2"]2}
    Temp += {["k3"]3}
    Temp @ [k]v {
        Prt(k)
        Prt(v)
    }
    Temp -= "k1"
    Prt(Temp["k2"])
}

TestLoop() -> () {
    Prt(" 0 to 10")
    [0 <= 10] @ i {
        Prt(i, ", ", "")
    }
    Prt(" ")
    Prt(" 0 to 8 step 2")
    [0 < 8, 2] @ ea {
        Prt(ea, ", ", "")
    }
    Prt(" ")
    Prt(" 8 to 2 step 2")
    [8 > 0, 2] @ ea {
        Prt(ea, ", ", "")
        ? ea == 6 {
            -> @
        }
    }
    Prt(" ")
    @ {
        <- @
    }
    A := 0
    B := 8
    @ A < B {
        A += 1
    }
}

TestCheck() -> () {
    Z1: ?Defer = Nil
    Defer{} ! Z2
    ! {
        Z1 = Defer{}
        Defer{} ! Z3
        X := 1 * 1
        Y := 1 + 1
    } ex: IOException {
        !(ex)
    } e {
        !(e)
    } _ {
        ? Z1 >< Nil {
            Z1.Dispose()
        }
    }
}

TestFunc(s: Str = "test") -> (out1: Str, out2: Int) {
    s = s + "test"
    I1 := 1+1*3*9/8
    I2 := I1 + 5 + (I1 + 8)
    # func in func #
    Infunc() -> () {
        <- ()
    }
    Infunc()

    <- (s, I2)
}

TestFuncParams(a: Int, b: Int, fn: (Int, Int, Int, I8) ->
    (Str, Int, Int, Int)) -> (a: Int, b: Str, c: Str) {
    <- (0, "", "")
}

TestLambda() -> () {
    Test1(fn: (Int, Int) -> (Int, Int)) -> () {
        (O1,O2) := fn(1, 2)
    }
    Test1( {i1,i2 -> (i1,i2)} )

    Test2(fn: () -> (Int)) -> () {
        O1 := fn()
    }
    Test2{->1}

    Test3(fn: (Int) ~> ()) -> () {
        fn(1)
    }
    Test3( (it: Int) ~> () {
        <~ Dly(1000)
        Prt(it)
    })
    Test3{it ~>
        <~ Dly(1000)
        Prt(it)
    }
    Test4(fn: (Int) ~> (Int)) -> () { 
        fn(18) 
    }
    Test4{it~>it+1}
}

TestAsync() ~> (x: Int, y: Int, z: Str) {
    Slp(1000)
    [1<=10] @ i {
        Go{ ~> 
            <~ Dly(1000)
            Prt("task", i)
        }
        Go{ -> 
            <- ()
        }
    }
    FunWait() ~> () {
        <~ Dly(1000)
    }
    <~ FunWait()
    
    <- (1, 2, "123")
}

TestLinq() -> () {
    Numbers := {0, 1, 2, 3, 4, 5, 6}
    Linq := from i -> in Numbers -> where (i % 2) == 0 ->
    orderby i -> descending -> select i
    Lambda := Numbers.Where{ i -> i%2==0 }.OrderBy{ i -> i }.ToList()
}

TestInterface(in: Protocol) -> () {}

ConstData :: 256
ConstData2: Str: "512"
ConstData3: Int: ConstData
ConstFunction() -> (v: Int) { 
    <- (ConstData) 
}

InPackageArray -> {
    arr: []Int = {1,2,3,4,5,6,7}
}

Defer -> {
    :IDisposable
    data := ""
}

(me: Defer) -> {
    Dispose() -> () {}
} 

App -> {
    :Program
    i := 555
    arr := {1,1,1,1}
    _priName := " Program "
    _b := 5
    _priF := "get"
}

(me: App) -> {
    testPackage() -> () {
        Item := Program{name = "new Program",running = True}
        Item2 := {
            name = "new Program",
            running = True
        }
        Item3 := []Int{1,2,3,4,5}
        Item4 := [Str]Int{["1"]1,["2"]2,["3"]3}
        Item5 := <PackageChild>(1,2) # New #
    }

    testFuncTemplate<T1, T2>(data1: T1, data2: T2) -> (data: App) {
        <- (me)
    }
}

(me: App) -> Protocol {
    b: Int -> get { 
        <- (me._b) 
    } set(v) { 
        me._b = v 
    }

    f: Str -> get {
        <- (me._priF)
    } set(v) {
        me._priF = v 
    }

    c(x: Int) -> (y: Int) {
        <- (x + me.b)
    }

    d() ~> (x: Int) {
        <~ Dly(1000)
        <- (3)
    }

    e() ~> () {
        <~ Dly(1000)
    }
} 

Result -> {
    data: Str
} 
(me: Result) <>(data: Str) {
    me.data = data
}

TestPackageTemplate<T:class> -> {
    data: T
}
(me:TestPackageTemplate<T>) -> {
    generic(a: T) -> () {}
} 

TestProtocolTemplate<T:class> <- {
    test<H:class>(in: H) -> ()
    test(in: T) -> ()
}

TestImplementTemplate -> {}
(me: TestImplementTemplate) -> TestProtocolTemplate<TestImplementTemplate> {
    test(in: TestImplementTemplate) -> () {}
    test<H:class>(in: H) -> () {}
} 

Program -> {
    _name: Str
    running: Bool
}

(me:Program) -> {
    name: Str -> get {
        <- (me._name)
    } set(v) {
        me._name = v
    }
}

Protocol <- {
    b: Int -> get,set
    c(x: Int) -> (y: Int)
    d() ~> (y: Int)
    e() ~> ()
    f: Str -> get,set
}

[Table("test")]
TestAnnotation -> {
    [Key, Column("id")]
    id: Str
    [Column("nick_name")]
    nickName: Str
    [Column("profile")]
    profile: Str
}

TestEnum -> Int[
    OK
    Error = -1
]

Package -> {
    x: Int
    y: Int
}
(me: Package) <>(y: Int = 3) {
    me.x = ConstData
    me.y = y
}
(me: Package) -> {
    parentFunc() -> () {
        me.x = 21
        Prt("package")
    }
} 

PackageChild -> {
    :Package
    x: Int
} 
(me: PackageChild) <>(x: Int, y: Int)(y) {
    me.x = x
}
(me: PackageChild)(super) -> {
    parentFunc() -> () {
        super.x = 64
        Prt("package child")
    }
} 
