demo
~System
~System\Linq
~System\Collections\Generic
~System\Text
~System\Threading\Tasks
~System\ComponentModel\DataAnnotations\Schema
~System\ComponentModel\DataAnnotations
{
    $
    {
        n0 := Node.{...Value=0};
        n1 := Node.{...Value=1};
        n2 := Node.{...Value=2};
        n3 := Node.{...Value=3};
        n4 := Node.{...Value=4};
        n5 := Node.{...Value=5};
        n6 := Node.{...Value=6};

        n0.Left = n1;
        n0.Right = n2;

        n1.Left = n3;
        n1.Right = n4;

        n2.Left = n5;
        n2.Right = n6;

        Console.WriteLine.("Pre Order Traverse");
        Action.PreorderTraverse.(n0);
        Console.WriteLine.("Middle Order Traverse");
        Action.MiddleorderTraverse.(n0);
        Console.WriteLine.("Post Order Traverse");
        Action.PostorderTraverse.(n0);

        n0 = Action.InverseNode.(n0);
        Console.WriteLine.("Inverse Node");
        Action.PreorderTraverse.(n0);

        arr := [9,1,5,8,3,7,4,6,2];
        Action.SimpleSort.(arr);
        arr = [9,1,5,8,3,7,4,6,2];
        Action.BubbleSort.(arr);
        arr = [9,1,5,8,3,7,4,6,2];
        Action.QuickSort.(arr);

        Console.WriteLine.("Filter Array");
        arr = Action.FilterList.(arr, $it <- it > 4);
        @ arr ~ i { Console.WriteLine.(i); };

        Console.WriteLine.("oop");
        app := App.{"test", "Windows"};
        app.Start.();
        app.Stop.();
        Action.Shutdown.(app);
        Console.ReadKey.();
    };

    Node #{}
    {
        Value :i32;
        Left :Node;
        Right :Node;
    };

    Action #
    {
        PreorderTraverse $(node:Node)->()
        {
            ? node == nil 
            {
                <- ();
            };
            Console.WriteLine.(node.Value);
            PreorderTraverse.(node.Left);
            PreorderTraverse.(node.Right);
        };

        PostorderTraverse $(node:Node)->()
        {
            ? node == nil 
            {
                <- ();
            };
            PreorderTraverse.(node.Left);
            PreorderTraverse.(node.Right);
            Console.WriteLine.(node.Value);
        };

        MiddleorderTraverse $(node:Node)->()
        {
            ? node == nil 
            {
                <- ();
            };
            PreorderTraverse.(node.Left);
            Console.WriteLine.(node.Value);
            PreorderTraverse.(node.Right);
        };

        InverseNode $(node:Node)->(node:Node)
        {
            ? node == nil 
            {
                <- (nil);
            };
            node.Left = InverseNode.(node.Left);
            node.Right = InverseNode.(node.Right);

            temp := Node.{
                ...Left = node.Right,
                Right = node.Left,
                Value = node.Value
            };
            <- (temp);
        };

        Swap $(list:[]i32, i, j:i32)->()
        {
            (list.[i], list.[j]) = (list.[j], list.[i]);
        };

        SimpleSort $(list:[]i32)->()
        {
            Console.WriteLine.("Simple Sort");
            @ [0~list.Count-1] ~ i
            {
                @ [i+1~list.Count-1] ~ j
                {
                    ? list.[i] > list.[j]
                    {
                        Swap.(list, i , j);
                    };
                };
            };
            @ list ~ item { Console.WriteLine.(item); };
        };

        BubbleSort $(list:[]i32)->()
        {
            Console.WriteLine.("Bubble Sort");
            @ [0~list.Count-1] ~ i
            {
                @ [list.Count-2~i;-1] ~ j
                {
                    ? list.[j] > list.[j+1]
                    {
                        Swap.(list, j , j+1);
                    };
                };
            };
            @ list ~ item { Console.WriteLine.(item); };
        };

        QuickSort $(list:[]i32)->()
        {
            Console.WriteLine.("Quick Sort");
            QSort.(list,0,list.Count-1);
            @ list ~ item { Console.WriteLine.(item); };
        };

        QSort $(list:[]i32, low, high:i32)->()
        {
            pivot := 0;
            ? low < high
            {
                pivot = Partition.(list,low,high);

                QSort.(list, low, pivot-1);
                QSort.(list, pivot+1, high);
            };
        };

        Partition $(list:[]i32, low, high:i32)->(position:i32)
        {
            pivotkey := list.[low];
            
            @ low < high
            {
                @ low<high && list.[high] >= pivotkey
                {
                    high -= 1;
                };
                Swap.(list, low , high);
                @ low<high && list.[low] <= pivotkey
                {
                    low += 1;
                };
                Swap.(list, low , high);
            };

            <- (low);
        };

        FilterList $(list:[]i32, fn:(take:i32)->(act:bool))->(l:[]i32)
        {
            filter := []i32.{};

            @ list ~ item 
            {
                ? fn.(item)
                {
                    filter.Add.(item);
                };
            };
            <- (filter);
        };

        Shutdown $(ctrl:Control)->()
        {
            ctrl.Shutdown.();
        };
    };

    Control &
    {
        Shutdown $()->(){};
    };

    Program #{name:str}
    {
        Name := "";
        _running := false;

        #
        {
            ..Name = name;
        };

        Start $()->()
        {
            Console.WriteLine.("Start");
            .._running = true;
        };

        Stop $()->()
        {
            Console.WriteLine.("Stop");
            .._running = false;
        };

        & Control
        {
            Shutdown $()->()
            {
                Console.WriteLine.("Shutdown");
                .._running = false;
            };
        };
    };

    App #{name, platform:str}~Program{name}
    {
        Platform :str;

        #
        {
            ..Platform = platform;
        };
    };
};