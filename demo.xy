demo
{
    .. System,
    System\Linq,
    System\Collections\Generic,
    System\Text,
    System\Threading\Tasks,
    System\ComponentModel\DataAnnotations\Schema,
    System\ComponentModel\DataAnnotations

    Main ()
    {
        n0 := Node.{...Value=0}
        n1 := Node.{...Value=1}
        n2 := Node.{...Value=2}
        n3 := Node.{...Value=3}
        n4 := Node.{...Value=4}
        n5 := Node.{...Value=5}
        n6 := Node.{...Value=6}

        n0.Left = n1
        n0.Right = n2

        n1.Left = n3
        n1.Right = n4

        n2.Left = n5
        n2.Right = n6

        Console.WriteLine.("Pre Order Traverse")
        PreorderTraverse.(n0)
        Console.WriteLine.("Middle Order Traverse")
        MiddleorderTraverse.(n0)
        Console.WriteLine.("Post Order Traverse")
        PostorderTraverse.(n0)

        n0 = InverseNode.(n0)
        Console.WriteLine.("Inverse Node")
        PreorderTraverse.(n0)

        arr := [9,1,5,8,3,7,4,6,2]
        SimpleSort.(arr)
        arr = [9,1,5,8,3,7,4,6,2]
        BubbleSort.(arr)
        arr = [9,1,5,8,3,7,4,6,2]
        QuickSort.(arr)

        Console.WriteLine.("Filter Array")
        arr = FilterList.(arr, it <- it > 4)
        arr.@ { Console.WriteLine.(it) }

        Console.WriteLine.("oop")
        app := App.{"test", "Windows"}
        app.Start.()
        app.Stop.()
        Shutdown.(app)
        Console.ReadKey.()
    }

    Node {}->
    {
        Value :i32?
        Left :Node?
        Right :Node?
    }

    PreorderTraverse (node:Node?)->()
    {
        node.? null { <- () }
        Console.WriteLine.(node.Value)
        PreorderTraverse.(node.Left)
        PreorderTraverse.(node.Right)
    }

    PostorderTraverse (node:Node?)->()
    {
        node.? null { <- () }
        PreorderTraverse.(node.Left)
        PreorderTraverse.(node.Right)
        Console.WriteLine.(node.Value)
    }

    MiddleorderTraverse (node:Node?)->()
    {
        node.? null { <- () }
        PreorderTraverse.(node.Left)
        Console.WriteLine.(node.Value)
        PreorderTraverse.(node.Right)
    }

    InverseNode (node:Node?)->(node:Node?)
    {
        node.? null { <- (null); }
        node.Left = InverseNode.(node.Left)
        node.Right = InverseNode.(node.Right)

        temp := Node.{
            ...Left = node.Right,
            Right = node.Left,
            Value = node.Value
        }
        <- (temp)
    }

    Swap (list:[]i32, i, j:i32)->()
    {
        (list.[i], list.[j]) = (list.[j], list.[i])
    }

    SimpleSort (list:[]i32)->()
    {
        Console.WriteLine.("Simple Sort")
        [0~list.Count-1].@ i
        {
            [i+1~list.Count-1].@ j
            {
                ? list.[i] > list.[j]
                {
                    Swap.(list, i , j)
                }
            }
        }
        list.@ { Console.WriteLine.(it) }
    }

    BubbleSort (list:[]i32)->()
    {
        Console.WriteLine.("Bubble Sort")
        [0~list.Count-1].@ i
        {
            [list.Count-2~i;-1].@ j
            {
                ? list.[j] > list.[j+1]
                {
                    Swap.(list, j , j+1)
                }
            }
        }
        list.@ { Console.WriteLine.(it) }
    }

    QuickSort (list:[]i32)->()
    {
        Console.WriteLine.("Quick Sort")
        QSort.(list,0,list.Count-1)
        list.@ { Console.WriteLine.(it); }
    }

    QSort (list:[]i32, low, high:i32)->()
    {
        pivot := 0
        ? low < high
        {
            pivot = Partition.(list,low,high)

            QSort.(list, low, pivot-1)
            QSort.(list, pivot+1, high)
        }
    }

    Partition (list:[]i32, low, high:i32)->(position:i32)
    {
        pivotkey := list.[low]
        
        @ low < high
        {
            @ low<high && list.[high] >= pivotkey
            {
                high -= 1
            }
            Swap.(list, low , high)
            @ low<high && list.[low] <= pivotkey
            {
                low += 1
            }
            Swap.(list, low , high)
        }

        <- (low)
    }

    FilterList (list:[]i32, fn:(take:i32)->(act:bool))->(l:[]i32)
    {
        filter := []i32.{}

        list.@ 
        {
            ? fn.(it)
            {
                filter.Add.(it)
            }
        }
        <- (filter)
    }

    Shutdown (ctrl:Control)->()
    {
        ctrl.Shutdown.()
    }

    Program {name:str}->
    {
        Name := ""
        _running := false

        ..
        {
            ..Name = name
        }
    }

    Program +=
    {
        Start ()->()
        {
            Console.WriteLine.("Start")
            .._running = true
        }

        Stop ()->()
        {
            Console.WriteLine.("Stop")
            .._running = false
        }
    }
    
    Control ->
    {
        Shutdown ()->(){}
    }

    Program += Control
    {
        Shutdown ()->()
        {
            Console.WriteLine.("Shutdown")
            .._running = false
        }
    }

    App {name, platform:str}-> Program.{name}
    {
        Platform :str

        ..
        {
            ..Platform = platform
        }
    }
}