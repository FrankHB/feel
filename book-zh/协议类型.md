# 协议
我们在现实中常常用协议来规定一些特定的规则，让人或事物可以按照预期的规则来做事情。
我们在程序语言里也常常需要这么做，这个功能就是协议。

协议规定用来实现某一特定功能所必需的方法和属性，让包来遵守。

我们的包可以像签署协议一样引入我们需要的协议，然后声明协议要求的所有属性，这样我们就认为这个包签署了协议。
## 定义
我们只需要使用符号 `&` 就可以定义一个协议。

例如：

    Protocol => &{};

这就是一个空的协议。

接下来，让我们设计一个学生都需要完成的艰巨任务……作业。

例如：

    HomeWork => &
    {
        Count => 0;
        Do => $()~(){};
    };

这是一个作业协议，它有两个属性，一个是需要做作业的数量，一个是完成作业的函数。

定义的方式和包内定义属性的方式如出一辙。

与包不同的是，协议定义时属性不需要具体的数值或函数内容，只需要确定类型。

接下来，我们就要让学生来实现这个协议了。
## 包含协议
我们可以在需要的包中，使用辅助符号 `~&` 和协议名搭配，就可以包含这个协议。

例如：

    Student => #~()
    {
        ...
        ~& HomeWork
        {
            Count => 999999; // 很多很多作业

            Do => $()~()
            {
                SpendTime(1); // 花费了一个小时
                ^.HomeWork.Count -= 1; // 完成了一个
            };
        };
    };

我们的学生写作业真是非常艰苦的……

让我们来解释一下这段包含协议发生了什么：
1. 我们定义了一个协议属性，这个属性的标识符就是协议的名称 `HomeWork`， 所以我们可以像定义了一个属性一样去使用它。
1. 在协议内我们包含了协议规定的两个属性 `Count, Do` ，根据规定，一个也不能少。
1. 我们给协议的两个属性都分别编写了真实的值和函数，这样这两个属性就成为了 `Student` 的有效子属性之一。
1. 我们在 `Do` 里面做了一些事情，并且通过调用 `HomeWork` 的属性减少了作业的总量。

需要注意的是，协议属性也是属性，我们在一个包内不能实现两个同名的协议，也不能有其它属性或方法与协议同名，但是不同名的协议所包含的方法允许同名。

## 使用协议
包含了协议之后，我们就能使用拥有协议的学生包了。

例如：

    Peter => Student~();
    Console.WriteLine(Peter.HomeWork.Count); 
    // 打印 999999 ，好多呀
    Peter.HomeWork.Do(); 
    // 做了一次作业
    Console.WriteLine(Peter.HomeWork.Count); 
    // 打印 999998 ，还是好多呀

如果只是这样使用，那和在包里直接定义这两个属性比就没什么优势了。

让我们来回想一下协议的作用，协议是让每个包含了协议的包都拥有了规定的相同的属性和方法。

这样对于协议的制定者来说，就无需关心包是如何遵循协议的，只需要知道它们都遵循了，就能用同样的方法去使用它们。

现在我们可以创建各种各样的学生，它们都遵循了一样的协议，我们可以无差别使用协议里的功能。

例如:

    // 创建了三个不同类型的学生包
    StudentA => ChinaStudent~();
    StudentB => AmericaStudent~();
    StudentC => JapanStudent~();
    // 让他们分别做作业
    StudentA.HomeWork.Do();
    StudentB.HomeWork.Do();
    StudentC.HomeWork.Do();

更有效率的做法是把这个功能写进函数，让函数来帮我们重复调用协议的功能。

我们可以在函数的参数类型里使用辅助符号 `&` 来标记参数是一个拥有协议的包，这样就能将包的协议传入使用。

例如：

    DoHomeWork => $(student: &HomeWork)~()
    {
        student.Do(); // 因为已经标记了协议，就可以使用协议中的方法了
    };
    // 现在我们就可以更简单地让每个学生做作业了
    DoHomeWork(StudentA.HomeWork);
    DoHomeWork(StudentB.HomeWork);
    DoHomeWork(StudentC.HomeWork);

当然，更好的做法是把这些学生都放进数组，这样我们就可以使用循环来处理这些重复的工作了。

例如：

    Arr => [&HomeWork]~();
    Arr.Add(StudentA.HomeWork);
    ... // 塞进很多很多学生
    @ Arr ~ Student
    {
        DoHomeWork(Student);
    };

╮（￣▽￣）╭  
完美
## 私有属性
和现实中的协议类似，协议也可以拥有一些公共资源提供给大家共同使用。

在我们的语言中，这可以是一些公共数据或者公共方法，正因为这些属性是协议写好时就已经约束好了，所以它们是不可更改的。

我们只需要定义私有属性就可以提供这些公共资源.

例如：

    HomeWork => &
    {
        ...
        _NeedHours => 1; // 不能修改
        _DoHomeWork => $(Student: &HomeWork)~()
        {
            Student.Do(); 
        };
    };

这样我们就拥有了两个公共属性，我们现在可以像标识符一样直接使用协议名称来调用这些属性，让我们来改造一些之前的代码。

例如：

    ...
    ~& HomeWork
    {
        ...
        Do => $ ()~()
        {
            SpendTime(HomeWork._NeedHours); // 花费了协议提供的数值
            ...
        };
    };
    ...
    @ Arr ~ Student
    {
        HomeWork._DoHomeWork(Student);
    };

╮（￣▽￣）╭  
再次完美

## 类型判断
因为包类型可以被转为协议类型使用，所以在使用过程中就不能确定数据的原始类型。

但有时候我们又需要获得数据的原始类型来处理，我们可以使用类型判断来帮助我们完成这个事情。

我们可以使用`?:`来判断数据的类型，使用`!:`来将数据转化为我们的类型。

例如：

    func => $(hw :&HomeWork)~()
    {
        // 判断是否中国学生
        ? hw ?: ChineseStudent
        {
            // 转换为中国学生数据
            cs => hw !: ChineseStudent;
        };
    };

`!:`如果不能正确地转换类型，会返回`nil`。

需要注意的是，只有包类型和协议类型支持转换。

### [下一章](检查.md)