# 协议
我们在现实中常常用协议来规定一些特定的规则，让人或事物可以按照预期的规则来做事情。
我们在程序语言里也常常需要这么做，这个功能就是协议。

协议规定用来实现某一特定功能所必需的方法和属性，让包来遵守。

我们的包可以像签署协议一样引入我们需要的协议，然后声明协议要求的所有属性，这样我们就认为这个包签署了协议。
## 定义
我们只需要使用 `id <- {}` 语句就可以定义一个协议。

例如：
```
protocol <- {
}
```
这就是一个空的协议。

接下来，让我们设计一个学生都需要完成的艰巨任务……作业。

例如：
```
homeWork <- {
    $count: i32
    do() -> ()
}
```
这是一个作业协议，它有两个属性，一个是需要做作业的数量，一个是完成作业的函数。

定义的方式和包内定义属性的方式如出一辙。

与包不同的是，协议定义时属性不需要具体的数值或函数内容，只需要确定类型。

接下来，我们就要让学生来实现这个协议了。
## 实现协议
我们可以在包声明后面，使用 `protocol {}` 语句来实现这个协议。

例如：
```
student() -> {
    todo("...")
} homeWork {
    $count: i32

    do() -> () {
        SpendTime(1)           # 花费了一个小时
        count -= 1   # 完成了一个
    }
}
```
我们的学生写作业真是非常艰苦的……

让我们来解释一下这段代码发生了什么：
1. 我们实现了一个协议，现在 `student` 也被认为是 `homework` 类型了，我们可以将一个 `student` 当作 `homework` 一样去使用。
1. 在协议内我们包含了协议规定的两个属性 `count, do` ，根据规定，一个也不能少。
1. 我们给协议的两个属性都分别编写了真实的值和函数，这样这两个属性就成为了 `student` 的有效子属性之一。
1. 我们在 `do` 里面做了一些事情，减少了作业的总量。

## 使用协议
包含了协议之后，我们就能使用拥有协议的学生包了。

例如：
```
Peter := student{ Count=999999 }
prt( Peter.count )
# 打印 999999，好多呀
Peter.do()
# 做了一次作业
prt( Peter.count )
# 打印 999998，还是好多呀
```
如果只是这样使用，那和在包里直接定义这两个属性比就没什么优势了。

让我们来回想一下协议的作用，协议是让每个包含了协议的包都拥有了规定的相同的属性和方法。

这样对于协议的制定者来说，就无需关心包是如何遵循协议的，只需要知道它们都遵循了，就能用同样的方法去使用它们。

现在我们可以创建各种各样的学生，它们都遵循了一样的协议，我们可以无差别使用协议里的功能。

例如:
```
# 创建了三个不同类型的学生包
StudentA := chineseStudent()
StudentB := americaStudent()
StudentC := japaneseStudent()
# 让他们分别做作业
StudentA.do()
StudentB.do()
StudentC.do()
```
更有效率的做法是把这个功能写进函数，让函数来帮我们重复调用协议的功能。

例如：
```
doHomeWork(student: homeWork) -> () {
    student.do()
}
# 现在我们就可以更简单地让每个学生做作业了
doHomeWork(StudentA)
doHomeWork(StudentB)
doHomeWork(StudentC)
```
当然，更好的做法是把这些学生都放进数组，这样我们就可以使用循环来处理这些重复的工作了。

例如：
```
arr := [homeWork]{}
arr.add( StudentA )
todo("...") # 塞进很多很多学生
@ i <- arr {
    doHomeWork(i)
}
```
╮（￣▽￣）╭  
完美

## 类型判断
因为包类型可以被转为协议类型使用，所以在使用过程中就不能确定数据的原始类型。

但有时候我们又需要获得数据的原始类型来处理，我们可以使用类型判断来帮助我们完成这个事情。

我们可以使用`value.is<type>()`来判断数据的类型，使用`value.as<type>()`来将数据转化为我们的类型。

例如：
```
func(hw: homeWork) -> () {
    # 判断是否中国学生
    ? hw.is<chineseStudent>() {
        # 转换为中国学生数据
        cs := hw.as<chineseStudent>()
    }
}
```
需要注意的是，如果不能正确地转换类型，会得到一个`nil`结果。

### [下一章](enumeration-type.md)

## 本章示例
```
\Demo <- {
    System
}

example -> {
    Main() -> () {
        S := B()
        B.do()
        C( B )
    }
}

A <- {
    $x: i32
    do() -> () {}
}

B() -> {
    y := 5
} A {
    $x := 0
    do() -> () {
        x += 1
    }
}

C(a: A) -> () {
    a.do()
    ? a.is<B>() {
        prt( a.as<B>().y )
    }
}
```