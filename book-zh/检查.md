# 检查
程序可能会出现各种各样的异常。

- 可能是文件或者用户输入的内容导致的。
- 可能是编码错误或语言中缺少的功能。
- 当然，也可能是由于许多其他不可预知的因素。

异常无法完全避免，但是我们可以选择一些手段帮助我们检查和报告异常。

## 报告异常
我们可以在函数中的任何地方，使用`!.()`来声明一个异常数据。

例如：
```
ReadFile (name:Str)->()
{
    ? name.Length == 0
    {
        !.( Exception.{"something wrong"} )
    }
    ...
}
```
这样我们就声明了一个异常，异常说明是`something wrong`，一旦外部调用者使用了不合法长度的`name`，这个函数就会被强制中止，将这个异常向上报告，交给调用者处理。
## 检查异常
我们可以在使用赋值语句或表达式语句的时候，使用`.! id:type {}`语句来检查异常。
`id`可以省略，默认为`it`。   
`:type`也可以省略，默认为`Exception`。

例如：
```
f: File = ReadFile.("temp.txt").! err: Exception
{
    Console.WriteLine.(err.message)
}
```
当出现异常时，程序就会进入`!`区块，`err`为异常标识符，我们可以获取异常的信息，或者进行其它操作。

如果没有异常，则不会进入异常处理区块的逻辑。

一般情况下，我们可以在异常处理中进行提早返回或数据处理，如果有处理不了的异常，我们也可以继续向上报告。

例如：
```
Func.().! {
    // 可以手动中止
    // <- () 
    !.(it)
}
```

## 片段
如果我们碰到了总是需要重复声明的内容，例如连续的检查，总是返回一样的内容。

例如：
```
Do1.().! {
    Log.(it.msg)
    !.(it)
}
Do2.().! {
    Log.(it.msg)
    !.(it)
}
Do3.().! {
    Log.(it.msg)
    !.(it)
}
```

这样的写法非常繁琐而且没有价值。

我们可以用片段语句来优化这种内容，使用`id () {}`来声明片段语句，前面的括号为参数。

例如：
```
CheckError (it:Exception)
{
    Log.(it.msg)
    !.(it)
}
```

声明片段语句不会产生任何代码，只有在调用时才会将片段语句填入位置中，相当于自动化生成代码，这点与函数不同。

使用`-> id`即可使用片段语句，现在我们可以这样处理上面的例子。

例如：
```
Do1.().! -> CheckError
Do2.().! -> CheckError
Do3.().! -> CheckError
```

这样看来就轻松多了。

片段语句可以大量减少重复编写的代码，使得我们的工作更轻松，它不仅仅用来处理错误，也可以用来处理一般逻辑。

例如：
```
a := 0
Handle () 
{ 
    a *= a 
    print.(a)
}
a += 1
-> Handle
a += 5
-> Handle
a += 7
-> Handle
```

## 检查延迟
如果我们有一段功能希望无论程序正常或异常都能处理，例如关键资源的释放问题，我们可以使用检查延迟特性。

很简单，使用`! {}`就能声明一段检查延迟的语句。

例如：
```
func ()->()
{
    file := ReadFile.("./somecode.xy")
    !
    {
        file.Release.()
    }
    ...
}
```
这样我们就声明了`file.Release.()`这条释放文件的语句，这条语句不会被立刻执行，而是会等待函数退出前调用。

有了检查延迟，我们就可以无需关心函数如何退出，安全地处理某些任务。

需要注意的是，正因为检查延迟是函数退出前执行的，并且无论程序运行状态异常与否都会执行，所以检查延迟中不能使用返回语句。

例如：
```
...
!
{
    file.Release.()
    <- ()   // 错误，不能使用返回语句
}
```

### 检查延迟顺序
特别的，如果在一个语句块中使用了多个延迟语句，最终执行是按照倒序逐个执行。这是因为延迟语句都是放在最后执行的，所以先声明的就会最后执行，因此多个延迟语句就会按照声明的倒序来执行。

例如：
```
! { Console.WriteLine.("1") }
! { Console.WriteLine.("2") }
! { Console.WriteLine.("3") }

// 最终显示 3 2 1
```

### 检查延迟作用域
检查延迟的有效作用域仅仅是当前最靠近自己的一层语句块，这对于我们控制执行区域非常有帮助。

例如：
```
func ()->()
{
    ...
    [0<<5].@
    {
        // 不会影响到循环外的逻辑
        ! { Console.WriteLine.(it + 1) }
        Console.WriteLine.(it)
    }
    ...
}
```
### 自动释放
对于实现了自动释放协议的包，我们可以使用`!=`语法来定义变量，这样在函数执行完毕时就会自动释放。

例如：
```
res != FileResource.{"/test.xy"}
...
```

### [下一章](异步处理.md)

## 本章示例
```
Demo
{
    .. System, XyLang\Library

    Main ()
    {
        x: I32 = (1 * 1).! err 
        {
            !.(err)
        }

        x != Defer.{}
        !
        {
            x.content = "defer"
            Console.WriteLine.(x.content)
        }
    }

    Defer {} ->
    {
        content :Str
    }

    Defer += IDisposable
    {
        Dispose ()->()
        {
            ..content = null
        }
    }
}
```