# 检查
程序可能会出现各种各样的异常。

- 可能是文件或者用户输入的内容导致的。
- 可能是编码错误或语言中缺少的功能。
- 当然，也可能是由于许多其他不可预知的因素。

异常无法完全避免，但是我们可以选择一些手段帮助我们检查和报告异常。

## 报告异常
我们可以在函数中的任何地方，使用 `!()` 来声明一个异常数据。

例如：
```
readFile(name: Str) -> () {
    ? name.Len == 0 {
        !( Exception("something wrong") )
    }
    ......
}
```
这样我们就声明了一个异常，异常说明是 `something wrong`，一旦外部调用者使用了不合法长度的 `name`，这个函数就会被强制中止，将这个异常向上报告，交给调用者处理。
## 检查异常
我们可以使用 `! {}` 语句来检查异常，使用 `id:type {}` 来处理异常。
`:type`可以省略，默认为`Exception`。   

例如：
```
! {
    f := readFile("temp.txt")
} ex:IOException {
    !(ex)
} e {
    Prt(e.message)
}
```
当出现异常时，程序就会进入错误处理区块，`e` 为异常标识符，我们可以获取异常的信息，或者进行其它操作。

如果没有异常，则不会进入异常处理区块的逻辑。

一般情况下，我们可以在异常处理中进行提早返回或数据处理，如果有处理不了的异常，我们也可以继续向上报告。

例如：
```
! {
    Func()
} ex {
    # 可以手动中止
    # <- () 
    !(ex)
}
```

## 检查延迟
如果我们有一段功能希望无论程序正常或异常都能处理，例如关键资源的释放问题，我们可以使用检查延迟特性。

很简单，在检查的最后使用 `_ {}` 就能声明一段检查延迟的语句。

例如：
```
func() -> () {
    f: File
    ! {
        f = ReadFile("./somecode.xs")
    } _ {
        ? f >< Nil {
            f.Release()
        }
    }
    ......
}
```
这样我们就声明了 `f.Release()` 这条释放文件的语句，这条语句不会被立刻执行，而是会等待检查结束后调用。

有了检查延迟，我们就可以无需关心如何退出，安全地处理某些任务。

需要注意的是，正因为检查延迟是函数退出前执行的，并且无论程序运行状态异常与否都会执行，所以检查延迟中不能使用返回语句。

例如：
```
......
_ {
    f.Release()
    <- ()   # 错误，不能使用返回语句
}
```

### 自动释放
对于实现了自动释放协议的包，我们可以使用声明语法来定义变量，这样在检查执行完毕时就会自动释放。

例如：
```
! res := FileResource("/test.xs") {
    ......
}
......
```

### [下一章](asynchronous.md)

## 本章示例
```
\Demo <- {
    System
}

Main() -> () {
    ! {
        x: I32 = (1 * 1)
    } ex {
        !(ex)
    }

    x := Defer()
    ! y := Defer() {
        x.Content = "defer"
        Prt(x.Content)
    } e:Exception {
        !(e)
    } _ {
        ? x >< Nil {
            x.Dispose()
        }
    }
}

Defer() -> {
    Content: Str
} IDisposable {
    Dispose() -> () {
        ..Content = ""
    }
}
```
