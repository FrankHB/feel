# 控制类型
控制类型是对数据操作封装的代码块。

通常我们会将一些数据控制处理封装成为控制类型，这样在使用数据时就无需执行额外的方法。

## 简单定义
如果我们暂时不需要定义具体的控制方法，我们只需要使用`id():type`来定义一个控制类型。

例如：
```
number(): I32
```
这样便定义了一个没有额外方法的控制数据，它内置了默认的控制方法。

## 获取操作
如果我们想设定一个获取的操作，我们可以在后面加入`{ ctrl{} }`定义。

例如：
```
number(): I32 {
    get {           # 表示获取，相当于其它语言中的getter
        <- (7)      # 只返回 7
    }
}
```
这样number就具有了一个特殊的获取值方法，在调用number时会执行内部的逻辑。

需要注意的是，这个控制数据只有一个获取方法，那么它就只支持获取操作，调用者无法给它赋值。
## 设置操作
有了以上的例子，我们很自然能够想到设置操作改如何处理。

例如：
```
number(): I32 {
    ......
    set {       # 表示设置，相当于其它语言中的setter
        # ？？？该把值给谁？？？
    }
}
```
是的，这里引出了一个问题，控制类型是用来控制操作的，实现操作的时候无法使用自身来存储数据。  
因此我们需要使用另一个搭配的数据来使用控制类型。

例如：
```
_number := 0

number(): I32 {
    ......
    set {
        _number = value     # value代表输入的值
    }
}
```

需要注意的是，变量需要同时声明`获取`和`设置`方法。不变量只能声明`获取`方法。

一个完整的读写例子如下：
```
_number := 0
number(): I32 {
    get {
        <- (_number)
    }
    set {
        _number = value # value代表输入的值
    }
}
```

特别的，如果我们给 `number` 初始化，编译器会自动生成对应的 `_number` 私有变量, 这时我们就可以省去定义另一个变量的步骤。

例如：
```
number(): I32 = 0 {
    get {
        <- (_number)
    }
    set {
        _number = value 
    }
}
```

只有当我们需要实现操作细节的时候才需要如此处理控制数据。

在大部分时候，我们可以只使用简单定义来完成任务，因为没有特殊的操作，所以它内置了自己的值无需我们额外处理。

### [下一章](protocol-type.md)

## 本章示例
```
\Demo <- {
    System
}

Main() -> () {
    Prt(a)
    C = 5
    Prt(C)
    Prt(C)
}

A() : I32 {
    get { 
        <- (3) 
    }
}

B := 0
C() : I32 {
    get { 
        <- (B) 
    }
    set { 
        B = value 
    }
}
```