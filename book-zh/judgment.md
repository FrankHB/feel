# 判断
判断语句通过设定的一个或多个条件来执行程序，在条件为 `true` 时执行指定的语句，在条件为 `false` 时执行另外指定的语句。

我们只需要使用 `? value {}` 就可以声明判断语句，根据后面的值进入对应的区域。

例如：
```
? true {
    prt("true")  # true
}
```
## 布尔判断
当判断值只会为 `bl` 类型时，语句只有当为 `true` 时才执行。
如果我们同时需要处理其它情况，可以在之后使用 `value {}` 来继续声明另一个处理语句。
如果只需要 `false` 的情况，使用 `_ {}` 来声明。

例如：
```
b := false
? b {
    todo("...") # 因为 b 为 false，所以永不会进入这个分支 
} _ {
    todo("...") # 处理 false
}
```

我们也可以在中间插入更多判断，语言会自动将它们实现为连续处理。

例如：
```
i := 3
? i == 0 {
    todo("...")
} i == 1 {
    todo("...")
} i == 2 {
    todo("...")
}
```

相对于其它语言来说，这可以认为是 `if elseif else` 结构。
## 条件判断
如果我们需要对一个标志符进行判断，可以使用`? value -> case {}`语句，语句实现多条件匹配，搭配匹配条件来执行相应的逻辑，这样它就只会执行匹配成功的语句。

例如：
```
? i -> 1 {
    todo("...")
} 2 {
    todo("...")
}
```
这种条件判断非常适合对某一个标识符的多条件判断，避免编写过多的判断条件。

是的，就像上面布尔判断一样，这里的每一个条件被执行完成后都会被结束，并不会继续向下执行。

### 缺省条件
如果需要一个缺省条件来执行逻辑怎么做？我们可以使用一个匿名标识符`_`来完成这个目标。

例如：
```
? i -> 1 {
    todo("...")
} 2 {
    todo("...")
} _ {
    todo("...")
}
```
这样匹配不到的情况下，就会到缺省处理区域去执行。

相对于其它语言来说，这可以认为是 `switch case default` 结构。

### 模式匹配
条件判断还能做的更多，比如我们需要判断标志符的类型，
可以使用`? value -> id:type{}`语法来匹配类型，`id`可以省略。

例如：
```
? x -> :i32 {       # 是否 i32
    prt("i32")
} content:str {     # 是否 str
    prt(content)
} nil {             # 是否为 nil
    prt("nil")
}
```
### 获取类型
如果我们需要明确获取类型值，可以使用`?(id)`或`?(:type)`语法来获取。

例如：
```
?(expr)    # 获取表达式类型值
?(:type)   # 通过类型直接获取类型值
```
### [下一章](loop.md)

## 本章示例
```
\Demo <- {
    System
}

example -> {
    Main() -> () {
        a := 5
        ? a == 2 { 
            prt(2) 
        } a == 4 { 
            prt(4) 
        } _ { 
            prt("not find") 
        }

        b := 7
        ? b -> 5 { 
            prt(5) 
        } 7 { 
            prt(7) 
        } _ { 
            prt("not find") 
        }

        prt( ?(b) )
        prt( ?(:i32) )
    }
}
```