# 判断
判断语句通过设定的一个或多个条件来执行程序，在条件为 `True` 时执行指定的语句，在条件为 `False` 时执行另外指定的语句。

我们只需要使用 `? value {}` 就可以声明判断语句，根据后面的值进入对应的区域。

例如：
```
? True {
    Prt("True")  # 真
}
```
## 布尔判断
当判断值只会为 `Bool` 类型时，语句只有当为 `True` 时才执行。
如果我们同时需要处理其它情况，可以在之后使用 `value {}` 来继续声明另一个处理语句。
如果只需要 `False` 的情况，使用 `_ {}` 来声明。

例如：
```
B := False
? B {
    ...... # 因为 B 为 False，所以永不会进入这个分支 
} _ {
    ...... # 处理 False
}
```

我们也可以在中间插入更多判断，语言会自动将它们实现为连续处理。

例如：
```
I := 3
? I == 0 {
    ......
} I == 1 {
    ......
} I == 2 {
    ......
}
```

相对于其它语言来说，这可以认为是 `if elseif else` 结构。
## 条件判断
如果我们需要对一个标志符进行判断，可以使用`value ? case {}`语句，语句实现多条件匹配，搭配匹配条件来执行相应的逻辑，这样它就只会执行匹配成功的语句。

例如：
```
I ? 1 {
    ......
} 2 {
    ......
}
```
这种条件判断非常适合对某一个标识符的多条件判断，避免编写过多的判断条件。

是的，就像上面布尔判断一样，这里的每一个条件被执行完成后都会被结束，并不会继续向下执行。

### 缺省条件
如果需要一个缺省条件来执行逻辑怎么做？我们可以使用一个匿名标识符`_`来完成这个目标。

例如：
```
I ? 1 {
    ......
} 2 {
    ......
} _ {
    ......
}
```
这样匹配不到的情况下，就会到缺省处理区域去执行。

相对于其它语言来说，这可以认为是 `switch case default` 结构。

### 模式匹配
条件判断还能做的更多，比如我们需要判断标志符的类型，
可以使用`value ? id:type{}`语法来匹配类型，`id`可以省略。

例如：
```
X ? :Int {          # 是否 Int
    Prt("Int")
} content:Str {     # 是否 Str
    Prt(content)
} () {              # 是否为 Nil
    Prt("Nil")
}
```
### 获取类型
如果我们需要明确获取类型值，可以使用`?(id)`或`?(:type)`语法来获取。

例如：
```
?(expr)    # 获取表达式类型值
?(:type)   # 通过类型直接获取类型值
```
### [下一章](loop.md)

## 本章示例
```
\Demo <- {
    System
}

Main() -> () {
    A := 5
    ? A == 2 { 
        Prt(2) 
    } A == 4 { 
        Prt(4) 
    } _ { 
        Prt("not find") 
    }

    B := 7
    B ? 5 { 
        Prt(5) 
    } 7 { 
        Prt(7) 
    } _ { 
        Prt("not find") 
    }

    Prt( ?(B) )
    Prt( ?(:Int) )
}
```