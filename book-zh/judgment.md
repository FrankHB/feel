# 判断
判断语句通过设定的一个或多个条件来执行程序，在条件为 `True` 时执行指定的语句，在条件为 `False` 时执行另外指定的语句。

我们只需要使用 `? value {}` 就可以声明判断语句，根据后面的值进入对应的区域。

例如：
```
? True {
    Prt("True")  # 真 #
}
```
## 布尔判断
当判断值只会为 `Bool` 类型时，语句只有当为 `True` 时才执行。
如果我们同时需要处理其它情况，可以在之后使用 `value {}` 来继续声明另一个处理语句。
如果只需要 `False` 的情况，使用 `_ {}` 来声明。

例如：
```
B := False
? B {
    ...... # 因为 B 为 False，所以永不会进入这个分支 # 
} _ {
    ...... # 处理 False #
}
```

我们也可以在中间插入更多判断，语言会自动将它们实现为连续处理。

例如：
```
I := 3
? I == 0 {
    ......
} I == 1 {
    ......
} I == 2 {
    ......
}
```

相对于其它语言来说，这可以认为是 `if elseif else` 结构。
## 条件判断
如果我们需要对一个标志符进行判断，可以使用`value ? case {}`语句，语句实现多条件匹配，搭配匹配条件来执行相应的逻辑，这样它就只会执行匹配成功的语句。

例如：
```
I ? 1 {
    ......
} 2 {
    ......
}
```
这种条件判断非常适合对某一个标识符的多条件判断，避免编写过多的判断条件。

是的，就像上面布尔判断一样，这里的每一个条件被执行完成后都会被结束，并不会继续向下执行。

### 缺省条件
如果需要一个缺省条件来执行逻辑怎么做？我们可以使用一个匿名标识符`_`来完成这个目标。

例如：
```
I ? 1 {
    ......
} 2 {
    ......
} _ {
    ......
}
```
这样匹配不到的情况下，就会到缺省处理区域去执行。

相对于其它语言来说，这可以认为是 `switch case default` 结构。

### 模式匹配
条件判断还能做的更多，比如我们需要判断标志符的类型，
可以使用`value ? id:type{}`语法来匹配类型，`id`可以省略。

例如：
```
X ? :Int {          # 是否 Int #
    Prt("Int")
} content:Str {     # 是否 Str #
    Prt(content)
} () {              # 是否为 Nil #
    Prt("Nil")
}
```
### 获取类型
如果我们需要明确获取类型值，可以使用`?(id)`或`?(:type)`语法来获取。

例如：
```
?(expr)    # 获取表达式类型值 #
?(:type)   # 通过类型直接获取类型值 #
```
### [下一章](loop.md)

## 本章示例
```
"Demo" {
    "System"
}

Main() -> () {
    A := 5
    ? A == 2 { 
        Prt(2) 
    } A == 4 { 
        Prt(4) 
    } _ { 
        Prt("not find") 
    }

    B := 7
    B ? 5 { 
        Prt(5) 
    } 7 { 
        Prt(7) 
    } _ { 
        Prt("not find") 
    }

    Prt( ?(B) )
    Prt( ?(:Int) )
}
```

# 循环
有的时候，我们可能需要多次执行同一块代码。

一般情况下，语句是按顺序执行的，函数中的第一个语句先执行，接着是第二个语句，以此类推。
## 集合循环
如果我们刚好有一个集合，可以是数组、字典、或是一段文本，那么我们就可以使用 `value @ id {}` 语句来遍历这个集合，取出的每一个元素为 `id`。

例如：
```
Arr := {1, 2, 3, 4, 5}
Arr @ item {
    Prt(item)    # 打印每一个数字 #
}
```

如果我们需要同时取出索引与值，可以使用 `[index]value` 语法替换 `id`，这个方式对列表和字典都有效。

例如：
```
Arr @ [i]v {
    Prt(""i":"v"")
}
```

相对于其它语言来说，这可以认为是 `foreach` 结构。
## 迭代器循环
有些时候，我们未必刚好就有一个集合，但是我们又需要从 `0` 到 `100` 去取数。我们有一个迭代器语法可以完成这样的任务。

迭代器可以从起点向终点循环取数，我们使用集合的表达方式，在两个数之间使用 `<=` 符号隔开即可。

例如：
```
[0 <= 100] @ i {
    Prt(i)      # 打印每一个数字 #
}
```
需要注意的是，`0 <= 100` 的意义是从 `0` 逐次读取到 `100` ，也就是一共执行了 `101` 次。迭代器会执行到最后一个数字被执行完毕，而不是提前一次结束。

因此如果我们需要的是执行一百次，可以使用 `0 < 99` 或 `1 <= 100-1` ，切记这个区别。

迭代器默认每次间隔累加 `1`，如果我们需要每隔一个数取一次，可以增加一个每步条件，只需要在起点和终点完成后再插入 `,` 和一个数字即可。

例如：
```
[0 <= 100, 2] @ i {
    ......
}
```
这样每次间隔就不是 `1` 而是 `2` ，同理我们可以设置其它数字。

我们也可以让它倒序遍历，只要使用 `>=` 即可。

例如：
```
[100 >= 0] @ i {
    ......     # 从100到0 #
}
```
同理，如果不希望到达最后一位，可以使用`100 > 0`。

相对于其它语言来说，这可以认为是 `for` 结构。
## 无限循环
在另一些时候，我们可能会需要一个无限循环。非常容易的是，我们只需要使用`@ {}`声明即可。

例如：
```
@ {
    ......     # 永远不会跳出 #
}
```
相对于其它语言来说，这可以认为是 `while` 结构。
## 跳出
那么要如何跳出无限循环呢？我们可以使用`<- @`语句来跳出。

例如：
```
@ {
    <- @     # 什么都没执行就跳出了 #
}
```
除了无限循环，跳出也可以在其它循环中使用。

需要注意的是，如果跳出在多层嵌套的循环中，只会跳出最靠近自己的那一层循环。
## 条件循环
如果我们需要一个只判断某个条件的循环怎么做呢？
加一个条件就可以了。

例如：
```
I := 0
@ I < 6 {
    I += 1
}
```
## 继续
如果只需要跳出当前循环，使用 `-> @` 语句即可。

