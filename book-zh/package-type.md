# 包
如果我们只有那几种基础数据，实际上非常难以描述更具体的东西。

因此我们需要一种，能将不同属性的数据包装起来的功能，才能更好地描述我们需要的东西。

显而易见，这个负责包装数据的功能，就是包。
## 定义
我们可以使用 `id -> {}` 语句来定义一个什么都没有的包。

例如：
```
package -> {
}
```
当然，我们更希望的是能包装几个数据，例如一个具有名称、学号、班级、年级属性的学生。
我们可以像定义普通标识符一样在包内去定义这些数据。

例如：
```
student -> {
    Name: Str = ""
    Number: Str = ""
    Class: I32 = 0
    Grade: I32 = 0
}
```
这样我们就得到了具有这几个数据属性的学生包。这个学生包现在就像 `I32,Str,Bl` 一样成为了一个可以使用的类型。

不像我们原始的基础类型只能存储一种数据，这个学生包可以同时存储名称、学号、班级、年级这些数据。

这非常像是我们现实中将不同的零件拼装在一起包装成一个整体的概念，因此它就被称之为包。

## 创建
那么我们怎么创建一个新的包呢？老样子，我们所有的类型都可以使用构造函数 `type{}` 来创建。

例如：
```
peter := student{}
```
这样便创建了一个 `peter` 标识符，这个学生的所有属性都根据定义中设置的那样被初始化为 `"","",0,0` 。

让我们回顾一下，我们的基础类型、集合类型都可以使用构造函数来创建，实际上它们都是包.

## 使用属性
现在我们已经有了一个 `peter` ，我们要怎么使用里面的属性呢？

很简单，我们只需要使用 `.` 语法，就能召唤出我们需要的属性。

例如：
```
Prt( peter.Name )      # 打印了某个学生的名字
```
要更改属性的值也是一样的，它就相当于是个嵌套的标识符。我们可以直接用赋值语句去更改值。

例如：
```
peter.Name = "peter" 
peter.Number = "060233"
peter.Class = 2
peter.Grade = 6
```
## 构建赋值
像上面那样创建一个新的包，再逐个装填数据非常麻烦，我们可以使用简化语法来配置。

在构建语法里面加上 `key=value` ，多个数据用 `,` 隔开。  

例如：
```
peter := student{
    Name="peter", Number="060233",
    Class=2, Grade=6
}
```

同样的，集合的创建方式其实就是一种构建语法，所以我们也可以这样创建数组和字典。

例如：
```
array := []I32{ 1, 2, 3, 4, 5 }
dictionary := [Str]I32{ ["1"]1, ["2"]2, ["3"]3 }
```
## 匿名包
如果我们只想直接包裹某些数据使用，而不是先定义包再使用，像匿名函数那样可以吗？

当然可以的，我们直接使用 `{}` 包裹就可以了，与集合的语法相同，只有里面的元素语法不同。

例如：
```
peter := {
    Name = "peter",
    Number = "060233",
    Class = 2,
    Grade = 6
}
```

这样就直接创建了一个 `peter` 数据，我们可以直接使用这些数据，但是不可更改这些数据。

由于匿名包并不是一个具有明确类型的包，所以我们只建议在一些临时场合使用，例如LINQ。

## 私有属性
任何人都会有些小秘密， `peter` 也一样，也许他藏了一个秘密小女友的名字不想让其他人知道。

我们可以定义私有属性来存储一些不想被外界访问的属性。

例如：
```
student -> {
    ......
    _GirlFriend: Str # 第一个字符是 _ 的标识符是私有的
}
```
没错，如果你还记得标识符的定义的话，这就是私有标识符的定义方式，私有标识符是不能被外界访问的。

因此我们再定义一个 `peter` 的话，也不能通过 `peter._GirlFriend` 来获取值或修改值。

那这种包的私有属性又不能访问，又不能修改，有什么用呢？别急，包还有另外一种属性。

## 函数
如果我们需要让这个包自带函数，让它能方便操作，我们也可以在包内直接定义。

例如：
```
student -> {
    ......
    _GirlFriend: Str
    GetGirlFriend() -> (name: Str) {
        <- (.._GirlFriend)
    }
}
```

这里的 `..` 用来声明包自身，这样可以方便地访问自身的属性。这可以认为是其它语言中的 `this | self` 。

通过函数属性，我们就能获取到私有的属性，也可以方便地根据业务需求去处理包中的其它数据。

有了这个函数，我们就可以通过调用函数去获取私有属性了。

例如：
```
Prt( peter.GetGirlFriend() ) 
# 打印了某个早恋学生的女朋友名字
```
与数据属性一样，函数也可以是私有标识符，使用私有标识符的函数也意味着只有包自己能访问。


## 组合
现在让我们发挥我们的想象力，我们想要一个专门给中国学生定制的数据包该怎么定义呢？

例如：
```
chineseStudent -> {
    Name: Str = ""
    Number: Str = ""
    Class: I32 = 0
    Grade: I32 = 0
    Kungfu: Bl = False     # 不会功夫的学生
}
```
不不不，这样重复定义数据就很不优雅了，我们可以将学生属性复用，加上一个额外的功夫属性就可以了。

我们需要用到组合这个特性，但是没有那么复杂，只是创建了一个学生属性而已。

例如：
```
chineseStudent -> {
    Student := student{}   # 将学生属性包含其中
    Kungfu := False        # 不会功夫
}
```
这样你就可以通过中国学生里的学生属性来使用通用属性。

例如：
```
chen := chineseStudent{}
Prt( chen.Student.Name )
# 当然，因为没有赋值，所以什么也没有输出
```
通过组合一层又一层的包，你可以自由拼装出任何一个你想要描述的事物。

## 兼容 .NET
以下内容为兼容性功能，如无必要，不推荐使用

### 继承
如果我们希望定义一个新的包，并且完全继承某个包的所有属性，可以使用继承语法, 在定义后面追加 `...id {}` 。
如果希望改写原始包的属性，在 `{}` 中重写即可。

例如：
```
chineseStudent -> {
    Kungfu := False
} ...student {   # 继承 student
    # 重写
    GetGirlFriend() -> (name: Str) {
        <- ("none")
    }
}
```
### 构造
有些时候，我们可能使用 .NET 中的构造方法。

我们可以在定义后面追加 `(id:type){}` 语句就可以了。

例如：
```
student -> {
    ......
} (name: Str, number: Str) {
    ..Name = name
    ..Number = number
    # 计算得出班级
    ..Class = GetSubText(number, 2, 3)
    # 计算得出年级
    ..Grade = GetSubText(number, 0, 1)
}
```
这样就得到了一个带构造函数的包，我们在创建一个新学生的时候，就会自动产生班级和年级数据。

我们需要使用 `New<type>()` 函数来使用构造函数。

例如：
```
peter := New<student>("peter", "060233")
Prt(peter.Class)     # 打印出 2
```

如果需要使用带继承的构造函数，可在参数语法后面追加 `...(params)` 即可。

例如：
```
Parent -> {
} (a:I32) {
}

Child -> {
} (a:I32)...(a) {
} ...Parent {
}
```

### [下一章](namespace.md)

## 本章示例
```
\Demo <- {
    System
}

Main() -> () {
    a := S{A=5,B=12}
    b := PKG(X="hello", Y=64, Z=a)
    Prt( b.Z.A )
    Prt( b.Print() )
}

S -> {
    A := 0
    B := 0
}

PKG -> {
    X := ""
    Y := 0
    Z :S

    Print() -> (a: Str) {
        <- ( "X {Y}" )
    }
} 
```