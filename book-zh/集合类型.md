# 集合类型
当我们需要将很多相同类型的数据组合在一起的时候，我们就可以使用集合来完成这个任务。

我们内置的集合类型有列表和字典两种。

## 列表
列表使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个列表的不同位置中。

### 定义
我们只需要使用 `{ e1,e2,e3:type }` 语法将我们需要的数据括起来，并用 `,` 分割每一个数据，就可以创建一个列表。  
在大部分情况下，数据类型都可以由语言自动推断，因此`:type`可以省略。

例如：
```
list := { 1,2,3,4,5 }
```
这样便会创建一个包含 `1` 到 `5` 的 `i32` 类型列表。

如果你需要一个明确类型的列表，可以使用类型标记或类型创建语法来创建。

列表类型的表示方法是`[]type`，`[]`表示为一维列表，因此多维列表可以表示为`[][][]type`。

例如我们需要一个字符串列表：
```
list := {"1,"2","3" :str}    # 标记类型
list2 := {:str}              # 空列表
list3 := []str.{}            # 类型创建
```
#### 数组
如果我们需要使用原生数组类型，可以使用`[|]type`来表示。
也可以使用`{|e1,e2,e3:type|}`直接创建。

例如：
```
arr := [|]i32.{}
arr2 = {|1,2,3,4,5|}
```
### 访问
如果我们需要访问列表中的其中一个元素，我们可以用 `标识符.[索引]` 来访问。

例如：
```
cmd.print.( list.[1] )
```
需要注意的是，在编程语言里，大多数列表起始索引都是从 `0` 开始的，`标识符.[0]` 取得的才是第一个元素，往后的元素以此类推。
### 更改元素
如果我们需要更改列表中的其中一个元素，我们可以直接访问该元素，使用赋值语句来更改。

例如：
```
list.[0] = 5
```
需要注意的是，我们只能访问已经存在数据的索引，如果不存在，则会出现错误。
### 常用操作
```
list += 1                # 添加到末尾
list.insert.(2, 3)       # 插入元素 3 到索引 2
list -= 1                # 删除指定位置元素
length := list.count     # 长度
```
## 字典
字典是用来存储无序的相同类型数据的集合，字典每个值（value）都关联唯一的键（key），键作为字典中的这个值数据的标识符。

和列表中的数据项不同，字典中的数据项并没有具体顺序。我们需要通过标识符（键）访问数据，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。

字典的键只能使用 `整数` 和 `字符串` 类型。
### 定义
和列表类似，字典也使用 `{}` 定义，不同的是字典的类型是 `key` 和 `value` 的联合类型，中间使用 `->` 隔开。

例如：
```
dictionary := {"a"->1, "b"->2, "c"->3}
```
这样便会创建一个包含 `a,b,c` 三个条目 的 `str->i32` 类型字典。

如果你需要一个明确类型的字典，同样可以使用类型标记或类型创建语法来创建。

字典类型的表示方法是`[type]type`，`[type]`表示的是一维字典，因此嵌套的字典可以表示为`[type][type][type]type`。

这和上面的列表表示方法几乎一致，没错，列表和字典其实本质都是通过索引来定位数据的集合，`[]`表示的就是索引的类型。

列表是因为只支持数字索引所以可以省略掉`[i32]`的标记，我们可以通过扩展`[i32]type`来实现功能一致的列表类型，但我们通常不需要那么做（时间就是金钱我的朋友！）。

例如：
```
dictionaryNumNum := { :i32->i32 }
dictionaryNumNum2 := [i32]i32.{}
```
### 访问
和列表类似，我们也可以使用索引直接访问数据。

例如：
```
cmd.print.( dictionary.["a"] )
```
### 更改元素
和列表类似，我们也可以使用赋值语句来更改元素。

例如：
```
dictionary.["b"] = 5
```
和列表不同的是，如果赋值的是不存在的索引，也不会错误，会直接将值赋予给新的键。
### 常用操作
```
dictionary += {"d"->11}        # 添加元素
dictionary -= "c"              # 删除指定索引元素
length := dictionary.count     # 长度
```
### [下一章](判断.md)

## 本章示例
```
Demo {
    System
    Library
}

main () {
    list1 := {1,2,3,4,5}
    list1 += 6
    list2 :[]i8 = {1,2,1,2 :i8}
    list3 := {|1,2,3|}

    dictionary1 := {"a"->1, "b"->2, "c"->3}
    dictionary1.["d"] = 4
    dictionary2 :[i8]i8 = {1->1,2->2,3->3 :i8->i8}
}
```