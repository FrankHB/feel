# 循环
有的时候，我们可能需要多次执行同一块代码。

一般情况下，语句是按顺序执行的，函数中的第一个语句先执行，接着是第二个语句，以此类推。
## 集合循环
如果我们刚好有一个集合，可以是数组、字典、或是一段文本，那么我们就可以使用 `@ id <- value {}` 语句来遍历这个集合，取出的每一个元素为 `id`。

例如：
```
arr := _{1, 2, 3, 4, 5}
@ item <- arr {
    cmd.print(item)    # 打印每一个数字
}
```

如果我们需要同时取出索引与值，可以使用`index -> value`语法替换`id`，这个方式对列表和字典都有效。

例如：
```
@ i -> v <- arr  {
    cmd.print("{i}:{v}")
}
```

相对于其它语言来说，这可以认为是 `foreach` 结构。
## 迭代器循环
有些时候，我们未必刚好就有一个集合，但是我们又需要从 `0` 到 `100` 去取数。我们有一个迭代器语法可以完成这样的任务。

迭代器可以从起点向终点循环取数，我们使用集合的表达方式，在两个数之间使用 `<=` 符号隔开即可。

例如：
```
@ i <- [0 <= 100] {
    cmd.print(i)      # 打印每一个数字
}
```
需要注意的是，`0 <= 100` 的意义是从 `0` 逐次读取到 `100` ，也就是一共执行了 `101` 次。迭代器会执行到最后一个数字被执行完毕，而不是提前一次结束。

因此如果我们需要的是执行一百次，可以使用 `0 < 99` 或 `1 <= 100-1` ，切记这个区别。

迭代器默认每次间隔累加`1`，如果我们需要每隔一个数取一次，可以增加一个每步条件，只需要在起点和终点完成后再插入`,`和一个数字即可。

例如：
```
@ i <- [0 <= 100, 2] {
    ...
}
```
这样每次间隔就不是 `1` 而是 `2` ，同理我们可以设置其它数字。

我们也可以让它倒序遍历，只要使用 `>=` 即可。

例如：
```
@ i <- [100 >= 0] {
    ...     # 从100到0
}
```
同理，如果不希望到达最后一位，可以使用`100 > 0`。

相对于其它语言来说，这可以认为是 `for` 结构。
## 无限循环
在另一些时候，我们可能会需要一个无限循环。非常容易的是，我们只需要使用`@ {}`声明即可。

例如：
```
@ {
    ...     # 永远不会跳出
}
```
相对于其它语言来说，这可以认为是 `while` 结构。
## 跳出
那么要如何跳出无限循环呢？我们可以使用`<- @`语句来跳出。

例如：
```
@ {
    <- @     # 什么都没执行就跳出了
}
```
除了无限循环，跳出也可以在其它循环中使用。

需要注意的是，如果跳出在多层嵌套的循环中，只会跳出最靠近自己的那一层循环。
## 条件循环
如果我们需要一个只判断某个条件的循环怎么做呢？
加一个条件 `?` 就可以了。

例如：
```
I := 0
@ ? I < 6 {
    I += 1
}
```
## 继续
如果只需要跳出当前循环，使用`-> @`语句即可。

### [下一章](function-type.md)

## 本章示例
```
\Demo {
    System
    Library
}

example. -> {
    Main() -> () {
        arr := _{1,2,3,4,5}
        @ i <- arr {
            cmd.print(i)
        }

        @ i <- [1 <= 50] {
            cmd.print(i)
        }

        @ i <- [100 >= 0, 2] {
            cmd.print(i)
        }

        X := 0
        @ ? X <= 10 {
            X += 1
        }
    }
}
```