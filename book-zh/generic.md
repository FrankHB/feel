# 泛型
在封装公共组件的时候，很多时候我们的包、方法、协议不需要关注调用者传递的实体是"什么"，这个时候就可以使用泛型。  

比如我们现在需要一个集合，可以支持增加、删除和读取，希望任何类型都可以使用，就可以封装一个泛型的包。 

我们的列表和字典其实就是使用泛型实现的。

## 声明与使用
让我们来看看怎么使用泛型来实现一个列表，我们只需在标识符后面使用`<>`符号来包裹类型的代称即可。

这是一个简化的实现。

例如：
```
List<T> {}-> {
    items := Storage{T}    # 创建存储
    length := 0
}
List<T> += {
    get (index:i32)->(item:T) { # 获取某个泛型数据
        <- ( items.get( index ) )
    }

    add (item:T)->() {   # 将一个泛型数据添加进列表
        items.insert(length, item)
        length += 1
    }
}
```
这样我们便定义一个支持泛型的包，`T`就是泛型的代×，实际上它可以是任何标识符，只是习惯性我们会使用`T`作为代称。

泛型括号内像参数一样支持多个代称，例如：`<T,H,Q>`。

定义了泛型之后，在包的区域内，就会将`T`看作是真正的类型，之后我们可以像`i32`一样在各种需要类型的地方使用它。

需要注意的是，因为泛型是在运行中确定类型的，所以编译器无法推断泛型的构造方法。我们只能用空类型构造方法去构造泛型数据。

例如：
```
Package<T> {}-> {
    item := lib.def<T>()    # 初始化了一个空值的泛型数据
}
```
那么我们如何使用泛型呢？

很简单，就和我们声明一样去使用即可，只不过调用时需传入真正的类型。

例如：
```
ListNumber := List<i32>{}      # 传入 integer 类型
```
这样我们便拥有了一个整数类型的列表，是不是很像这个：
```
ListNumber := [i32]{}
```
没错，其实我们的列表和字典语法都是语法糖，实际类型分别是`lst`和`dic`。
## 支持的类型
我们可以在 包、函数、协议 类型中使用泛型。

例如：
```
Func<T> (data:T)->(data:T) {
    <- (data)
}

Protocol<T> -> {
    test<T> (in:T)->(){}
}

Implement += Protocol<Implement> {
    test<Implement> (in:Implement)->(){}
}
```
### [下一章](annotation.md)