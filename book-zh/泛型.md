# 泛型
在封装公共组件的时候，很多时候我们的包、方法、协议不需要关注调用者传递的实体是"什么"，这个时候就可以使用泛型。  

比如我们现在需要一个集合，可以支持增加、删除和读取，希望任何类型都可以使用，就可以封装一个泛型的包。  

也许你已经回想起来了，我们的集合使用了`System.Collections.Generic;`这个命名空间，这个便是泛型。  

我们的数组和字典其实就是使用泛型实现的。

同样的，我们需要引入泛型命名空间才可以使用泛型。
```
System.Collections.Generic;
```
## 声明与使用
让我们来看看怎么使用泛型来实现一个数组，我们只需在标识符后面使用`<>`符号来包裹类型的代称即可。

这是一个简化的实现。

例如：
```
Array<T> => #()
{
    Items => #Storage.(T); // 创建存储
    Length => ^i32;

    Get => $(index:i32)~(item:T) // 获取某个泛型数据
    {
        -> (Items.Get.(index));
    };

    Add => $(item:T)~() //将一个泛型数据添加进数组
    {
        Items.Insert.(Length, item);
        Length += 1;
    };
};
```
这样我们便定义一个支持泛型的包，`T`就是泛型的代×，实际上它可以是任何标识符，只是习惯性我们会使用`T`作为代称。

泛型括号内像参数一样支持多个代称，例如：`<T,H,Q>`。

定义了泛型之后，在包的区域内，就会将`T`看作是真正的类型，之后我们可以像`i32`一样在各种需要类型的地方使用它。

需要注意的是，因为泛型是在运行中确定类型的，所以编译器无法推断泛型的构造方法。我们只能用空类型构造方法去构造泛型数据。

例如：
```
Package<T> => #()
{
    Item => ~:T; // 初始化了一个空值的泛型数据
};
```
那么我们如何使用泛型呢？

很简单，就和我们声明一样去使用即可，只不过调用时需传入真正的类型。

例如：
```
ArrNumber => #Array<i32>.(); // 传入 integer 类型
```
这样我们便拥有了一个整数类型的数组，是不是很像这个：
```
ArrNumber => #[]i32.();
```
## 支持的类型
我们可以在 包、函数、协议 类型中使用泛型。

例如：
```
Func<T> => $(data:T)~(data:T)
{
    -> (data);
};

Protocol<T> => &
{
    Test<T> => $(in:T)~(){};
};

Implement => #()
{
    ~& Protocol<Implement>
    {
        Test<Implement> => $(in:Implement)~(){};
    };
};
```
### [下一章](注解.md)